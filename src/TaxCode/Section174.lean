/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1c54f0c6-68bd-4443-a5d7-6716d36f5381
-/

/-
Formalization of IRC Section 174 (Amortization of Research and Experimental Expenditures).

This module defines the necessary types and structures to represent expenditures and tax years,
and implements the amortization schedule for foreign research and experimental expenditures
as specified in the provided legal text (including the 2025 amendment).

Key definitions:
- `Expenditure`: Structure capturing the details of an expenditure.
- `yearly_deduction`: Calculates the deduction amount for a given tax year.
- `deduction_sum_correct`: Theorem proving that the total deduction over the 15-year period equals the original expenditure amount.

The implementation uses exact integer arithmetic (`Currency := Int`) to avoid precision issues.
All major provisions regarding the calculation of the deduction are covered.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Currency, TaxYear, and FilingStatus types for IRC Section 174 formalization.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Define Expenditure structure and helper predicates for IRC §174 logic (retrying without Repr).
-/
structure Expenditure where
  amount : Currency
  year_paid : Nat
  is_research : Bool
  is_software : Bool
  is_foreign : Bool
  is_land_improvement : Bool
  is_exploration : Bool
  connected_to_trade : Bool
  deriving DecidableEq

-- IRC §174(c)(1) & (c)(2) exclusions
def is_excluded (e : Expenditure) : Bool :=
  e.is_land_improvement || e.is_exploration

-- IRC §174(c)(3) inclusion and general definition
def is_research_or_experimental (e : Expenditure) : Bool :=
  (e.is_research || e.is_software) && !is_excluded e

-- IRC §174(b) definition of "foreign research or experimental expenditures"
def is_foreign_research_or_experimental (e : Expenditure) : Bool :=
  is_research_or_experimental e && e.is_foreign && e.connected_to_trade

/-
Define Currency instances and amortization logic.
-/
-- Add instances for Currency to allow arithmetic operations
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance (n : Nat) : OfNat Currency n := inferInstanceAs (OfNat Int n)

def amortization_period : Nat := 15

-- Helper to calculate the cumulative deduction up to a given year offset (0-indexed)
def cumulative_deduction (total_amount : Currency) (offset : Nat) : Currency :=
  if offset >= amortization_period then
    total_amount
  else
    let amount_int : Int := total_amount
    let offset_int : Int := offset
    -- Formula: amount * (1 + 2 * offset) / 30
    let num := amount_int * (1 + 2 * offset_int)
    (num / 30 : Int)

def yearly_deduction (e : Expenditure) (tax_year : TaxYear) : Currency :=
  if !is_foreign_research_or_experimental e then
    0
  else
    let start_year := e.year_paid
    if tax_year.year < start_year then
      0
    else
      let offset := tax_year.year - start_year
      if offset > amortization_period then
        0
      else
        let current_cum := cumulative_deduction e.amount offset
        let prev_cum := if offset == 0 then 0 else cumulative_deduction e.amount (offset - 1)
        current_cum - prev_cum

/-
Helper lemma: the sum of differences (telescoping sum) over a range [0, n] equals the final value f(n), using List.sum.
-/
theorem telescoping_sum_list (f : Nat → Currency) (n : Nat) :
    ((List.range (n + 1)).map (fun i => f i - (if i = 0 then 0 else f (i - 1)))).sum = f n := by
  induction' n with n ih;
  · cases h : f 0 <;> aesop;
  · rw [ List.range_succ ];
    simp_all +decide [ List.sum ];
    convert congr_arg ( fun x => f ( n + 1 ) - f n + x ) ih using 1;
    · induction ( List.map ( fun i => f i - if i = 0 then 0 else f ( i - 1 ) ) ( List.range ( n + 1 ) ) ) <;> simp +decide [ * ];
      exact Int.add_left_comm _ _ _;
    · exact Eq.symm ( Int.sub_add_cancel _ _ )

/-
Lemma: For a valid offset `i` and valid tax year, `yearly_deduction` equals the difference in cumulative deductions.
-/
lemma yearly_deduction_simp (e : Expenditure) (h_elig : is_foreign_research_or_experimental e) (h_year : e.year_paid ≥ 1913) (i : Nat) (hi : i ≤ amortization_period) :
    yearly_deduction e ⟨e.year_paid + i, by
      grind⟩ =
    cumulative_deduction e.amount i - (if i = 0 then 0 else cumulative_deduction e.amount (i - 1)) := by
      unfold yearly_deduction;
      aesop

/-
Lemma: `foldl` with addition starting at 0 is equivalent to `sum` of `map`.
-/
lemma foldl_add_eq_sum_map {α : Type} (l : List α) (f : α → Currency) :
    l.foldl (fun s x => s + f x) 0 = (l.map f).sum := by
  induction l <;> simp_all +decide [ List.sum ];
  rename_i k hk ih; rw [ ← ih ] ;
  -- By the associativity of addition, we can rearrange the terms.
  have h_assoc : ∀ (a b : Currency) (l : List α), List.foldl (fun s x => s + f x) (a + b) l = a + List.foldl (fun s x => s + f x) b l := by
    intros a b l; induction' l using List.reverseRecOn with l ih generalizing a b <;> aesop;
    exact Int.add_assoc _ _ _;
  specialize h_assoc ( f k ) 0 hk ; aesop;
  convert h_assoc using 1;
  congr! 1;
  exact Int.add_comm _ _

/-
Prove that the sum of deductions over the amortization period equals the total expenditure amount.
-/
theorem deduction_sum_correct (e : Expenditure) (h_elig : is_foreign_research_or_experimental e) (h_year : e.year_paid ≥ 1913) :
    (List.range (amortization_period + 1)).foldl (fun sum i => sum + yearly_deduction e ⟨e.year_paid + i, by
      linarith⟩) 0 = e.amount := by
  -- Let's simplify the expression using the definition of `foldl`.
  have h_fold : List.foldl (fun (sum : Currency) (i : ℕ) => sum + yearly_deduction e ⟨e.year_paid + i, by
    linarith⟩) 0 (List.range (amortization_period + 1)) = List.sum (List.map (fun i => yearly_deduction e ⟨e.year_paid + i, by
    grind⟩) (List.range (amortization_period + 1))) := by
    have h_fold : ∀ (l : List ℕ) (f : ℕ → Currency), List.foldl (fun (sum : Currency) (i : ℕ) => sum + f i) 0 l = List.sum (List.map f l) := by
      exact?;
    grind
  generalize_proofs at *;
  -- Apply the yearly_deduction_simp lemma to each term in the sum.
  have h_apply_simp : ∀ i ∈ List.range (amortization_period + 1), yearly_deduction e ⟨e.year_paid + i, by
    exact?⟩ = cumulative_deduction e.amount i - (if i = 0 then 0 else cumulative_deduction e.amount (i - 1)) := by
    exact fun i hi => yearly_deduction_simp e h_elig h_year i ( by linarith [ Finset.mem_range.mp hi ] )
  generalize_proofs at *;
  rw [ h_fold, List.map_congr_left h_apply_simp ];
  convert telescoping_sum_list ( fun i => cumulative_deduction e.amount i ) amortization_period using 1
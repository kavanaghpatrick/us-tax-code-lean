/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8652337c-0d32-4392-bbbd-6cb221a4234f
-/

/-
Formalization of IRC Section 21 (Expenses for household and dependent care services necessary for gainful employment).

This module defines the necessary types and structures to represent taxpayers, qualifying individuals, and expenses. It implements the calculation of the applicable percentage based on AGI and filing status, determines if an individual qualifies, checks if expenses are employment-related, and calculates the final tax credit amount subject to dollar limits and income-based phaseouts.

Key definitions:
- `Currency`: Integer representation of currency.
- `FilingStatus`: Enumeration of tax filing statuses.
- `Person`: Structure representing an individual with relevant attributes for dependency and care.
- `Expense`: Structure representing a care expense.
- `calculate_applicable_percentage`: Computes the credit percentage based on AGI.
- `is_qualifying_individual`: Determines if a person is a qualifying individual under §21(b)(1).
- `is_employment_related_expense`: Checks if an expense is employment-related under §21(b)(2).
- `calculate_credit`: Computes the final credit amount.

Theorems:
- `applicable_percentage_bounds`: Proves the percentage is between 20% and 50%.
- `credit_nonneg`: Proves the calculated credit is non-negative given non-negative expenses.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic type definitions for IRC Section 21 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Instances for Currency and the calculation of applicable percentage with a bounds theorem.
-/
-- Instances for Currency
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : Mod Currency := inferInstanceAs (Mod Int)
instance : ToString Currency := inferInstanceAs (ToString Int)
instance (n : Nat) : OfNat Currency n := ⟨(n : Int)⟩

def calculate_applicable_percentage (agi : Currency) (status : FilingStatus) : Nat :=
  let agi_val : Int := agi
  let base_percent : Int := 50

  -- Part (A)
  let threshold_a : Int := 15000
  let step_a : Int := 2000
  let excess_a : Int := if agi_val > threshold_a then agi_val - threshold_a else 0
  let reduction_a : Int := if excess_a > 0 then (excess_a + step_a - 1) / step_a else 0
  let after_a : Int := max 35 (base_percent - reduction_a)

  -- Part (B)
  let threshold_b : Int := if status == FilingStatus.MarriedFilingJointly then 150000 else 75000
  let step_b : Int := if status == FilingStatus.MarriedFilingJointly then 4000 else 2000
  let excess_b : Int := if agi_val > threshold_b then agi_val - threshold_b else 0
  let reduction_b : Int := if excess_b > 0 then (excess_b + step_b - 1) / step_b else 0

  -- "further reduced"
  let result : Int := max 20 (after_a - reduction_b)
  result.toNat

theorem applicable_percentage_bounds (agi : Currency) (status : FilingStatus) :
  let p := calculate_applicable_percentage agi status
  20 ≤ p ∧ p ≤ 50 := by
    unfold calculate_applicable_percentage;
    simp;
    split_ifs <;> omega

/-
Definitions for Relationship, Person, and the logic for determining if a person is a qualifying individual under IRC §21(b)(1).
-/
inductive Relationship
  | Child
  | Spouse
  | Other
  deriving DecidableEq, Repr

structure Person where
  id : String
  age : Nat
  is_dependent : Bool -- Simplified for Section 152
  is_incapable_of_self_care : Bool
  months_lived_with_taxpayer : Nat
  relationship : Relationship
  deriving DecidableEq, Repr

-- IRC §21(b)(1)
def is_qualifying_individual (p : Person) : Bool :=
  match p.relationship with
  | Relationship.Child =>
    -- (A) dependent under 13
    (p.is_dependent && p.age < 13) ||
    -- (B) dependent incapable of self-care and lived > 6 months
    (p.is_dependent && p.is_incapable_of_self_care && p.months_lived_with_taxpayer > 6)
  | Relationship.Spouse =>
    -- (C) spouse incapable of self-care and lived > 6 months
    (p.is_incapable_of_self_care && p.months_lived_with_taxpayer > 6)
  | Relationship.Other =>
    -- (B) other dependent incapable of self-care and lived > 6 months
    (p.is_dependent && p.is_incapable_of_self_care && p.months_lived_with_taxpayer > 6)

/-
Definitions for ExpenseCategory and Expense, and a function to determine if an expense is employment-related based on IRC §21(b)(2), now with Repr Currency instance.
-/
instance : Repr Currency := inferInstanceAs (Repr Int)

inductive ExpenseCategory
  | HouseholdService
  | CareInsideHousehold
  | CareOutsideHousehold (is_camp_overnight : Bool) (is_care_center : Bool)
  deriving DecidableEq, Repr

structure Expense where
  amount : Currency
  category : ExpenseCategory
  beneficiary : Person
  enable_employment : Bool
  center_complies : Bool -- Only relevant if CareOutsideHousehold with is_care_center
  deriving DecidableEq, Repr

-- Helper to check if an expense is employment-related under §21(b)(2)
def is_employment_related_expense 
    (e : Expense) 
    (spends_8_hours : Person → Bool) : Bool :=
  -- Must be incurred to enable employment
  if ¬e.enable_employment then false
  else
    -- Must be for a qualifying individual (we assume beneficiary is one, or we check it? 
    -- The text says "expenses for the care of a qualifying individual". 
    -- We will check is_qualifying_individual e.beneficiary in the main loop, 
    -- here we check the nature of the expense.)
    match e.category with
    | ExpenseCategory.HouseholdService => true
    | ExpenseCategory.CareInsideHousehold => true
    | ExpenseCategory.CareOutsideHousehold is_camp is_center =>
      if is_camp then false -- (A) Excludes camp overnight
      else
        -- (B) Outside services requirements
        let meets_outside_reqs := 
          -- (i) under 13 (which is (1)(A))
          (e.beneficiary.relationship == Relationship.Child && e.beneficiary.age < 13) ||
          -- (ii) spends at least 8 hours
          (spends_8_hours e.beneficiary)
        
        if ¬meets_outside_reqs then false
        else
          -- (C) Dependent care center requirements
          if is_center then e.center_complies else true

/-
Definition of dollar limit and credit calculation, with explicit type casting to avoid HMul errors, and a theorem for non-negative credit.
-/
def calculate_dollar_limit (num_qualifying : Nat) : Currency :=
  if num_qualifying == 0 then 0
  else if num_qualifying == 1 then 3000
  else 6000

def calculate_credit
    (agi : Currency)
    (status : FilingStatus)
    (expenses : List Expense)
    (people : List Person)
    (spends_8_hours : Person → Bool) : Currency :=
  let qualifying_people := people.filter is_qualifying_individual
  let num_qualifying := qualifying_people.length

  -- If no qualifying individuals, credit is 0 (implied by §21(a)(1))
  if num_qualifying == 0 then 0
  else
    let valid_expenses := expenses.filter (fun e =>
      is_employment_related_expense e spends_8_hours &&
      is_qualifying_individual e.beneficiary
    )

    let total_expenses : Currency := valid_expenses.foldl (fun sum e => sum + e.amount) 0
    let limit := calculate_dollar_limit num_qualifying
    let allowed_expenses := min total_expenses limit

    let percentage_nat : Nat := calculate_applicable_percentage agi status
    let percentage : Currency := (percentage_nat : Int)

    (allowed_expenses * percentage) / 100

theorem credit_nonneg
    (agi : Currency)
    (status : FilingStatus)
    (expenses : List Expense)
    (people : List Person)
    (spends_8_hours : Person → Bool)
    (h_expenses_nonneg : ∀ e ∈ expenses, e.amount ≥ 0) :
    calculate_credit agi status expenses people spends_8_hours ≥ 0 := by
      unfold calculate_credit; aesop;
      refine' Int.ediv_nonneg ( mul_nonneg _ _ ) _ <;> norm_num;
      refine' ⟨ _, _ ⟩;
      · induction expenses using List.reverseRecOn <;> aesop;
        rw [ List.filter_cons ] ; aesop;
        exact add_nonneg a_1 ( h_expenses_nonneg a ( Or.inr rfl ) );
      · unfold calculate_dollar_limit;
        split_ifs <;> norm_num
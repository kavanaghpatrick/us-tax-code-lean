/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bd392fc4-be76-4b07-ba89-35f3b35ce945
-/

/-
Formalization of IRC Section 163 (Interest).

This module defines the structures and functions necessary to calculate the interest deduction allowed under IRC §163, specifically focusing on:
- §163(b): Imputed interest on installment purchases where interest is not separately stated.
- §163(c): Redeemable ground rents treated as interest.
- §163(d): Limitation on investment interest.

It includes:
- Type definitions for `Currency`, `TaxYear`, `FilingStatus`, `Contract`, and `InvestmentContext`.
- Calculation functions for average unpaid balance, imputed interest, investment income, net investment income, and the investment interest limitation.
- Theorems verifying that the calculations respect the statutory limits (e.g., imputed interest does not exceed carrying charges, investment interest deduction does not exceed net investment income) and that amounts are non-negative.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Redefining basic types with `abbrev Currency := Int` to fix typeclass issues.
-/
-- Common definitions
abbrev Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Defines the Contract structure and implements the imputed interest calculation for installment purchases under IRC §163(b).
-/
structure Contract where
  -- Conditions for 163(b)(1)
  is_installment_plan : Bool
  carrying_charges_stated : Bool
  interest_ascertainable : Bool
  is_educational_or_personal : Bool
  
  -- Data for calculation
  -- "sum of the unpaid balance outstanding on the first day of each month beginning during the taxable year"
  unpaid_balances : List Currency 
  
  -- "aggregate carrying charges which are properly attributable to such taxable year"
  carrying_charges_attributable : Currency
  deriving DecidableEq, Repr

/-- 
IRC §163(b)(1): ...average unpaid balance is the sum of the unpaid balance outstanding on the first day of each month beginning during the taxable year, divided by 12.
-/
def average_unpaid_balance (c : Contract) : Currency :=
  (c.unpaid_balances.foldl (· + ·) 0) / 12

/--
IRC §163(b)(1): ...treated... as if they included interest equal to 6 percent of the average unpaid balance...
IRC §163(b)(2): ...shall not exceed the aggregate carrying charges which are properly attributable to such taxable year.
-/
def imputed_interest_163_b (c : Contract) : Currency :=
  if c.is_installment_plan ∧ c.carrying_charges_stated ∧ ¬c.interest_ascertainable ∧ c.is_educational_or_personal then
    let avg_balance := average_unpaid_balance c
    let interest := (avg_balance * 6) / 100
    min interest c.carrying_charges_attributable
  else
    0

/-
Defines InvestmentContext and implements calculations for investment income, net investment income, and the investment interest limitation and carryforward under IRC §163(d).
-/
/--
IRC §163(c): Redeemable ground rents.
-/
def redeemable_ground_rents_interest (rental_amount : Currency) : Currency :=
  rental_amount

structure InvestmentContext where
  -- 163(d)(3)(A)
  interest_paid_allocable_to_investment : Currency
  
  -- 163(d)(4)(B)
  gross_income_from_investment : Currency
  net_gain_disposition : Currency
  net_capital_gain_disposition : Currency
  capital_gain_elected : Currency
  
  -- 163(d)(4)(C)
  investment_expenses : Currency
  
  -- 163(d)(2)
  disallowed_interest_carryforward : Currency
  deriving DecidableEq, Repr

/--
IRC §163(d)(4)(B): Investment income.
-/
def investment_income (ctx : InvestmentContext) : Currency :=
  let part_i := ctx.gross_income_from_investment
  let part_ii := max 0 (ctx.net_gain_disposition - ctx.net_capital_gain_disposition)
  -- Clause (iii): so much of ... as the taxpayer elects
  -- We assume the input `capital_gain_elected` respects the limit, but we cap it just in case.
  let limit_iii := max 0 (min ctx.net_gain_disposition ctx.net_capital_gain_disposition)
  let part_iii := min (max 0 ctx.capital_gain_elected) limit_iii
  part_i + part_ii + part_iii

/--
IRC §163(d)(4)(A): Net investment income.
-/
def net_investment_income (ctx : InvestmentContext) : Currency :=
  (investment_income ctx) - ctx.investment_expenses

/--
IRC §163(d)(1): Limitation on investment interest.
Returns the amount allowed as a deduction.
-/
def allowed_investment_interest (ctx : InvestmentContext) : Currency :=
  let total_interest := ctx.interest_paid_allocable_to_investment + ctx.disallowed_interest_carryforward
  let limit := max 0 (net_investment_income ctx)
  min total_interest limit

/--
IRC §163(d)(2): Carryforward of disallowed interest.
-/
def disallowed_investment_interest_carryforward (ctx : InvestmentContext) : Currency :=
  let total_interest := ctx.interest_paid_allocable_to_investment + ctx.disallowed_interest_carryforward
  let allowed := allowed_investment_interest ctx
  total_interest - allowed

/-
Theorem: The imputed interest under §163(b) never exceeds the attributable carrying charges (assuming charges are non-negative).
-/
theorem imputed_interest_le_carrying_charges (c : Contract) (h_charges : 0 ≤ c.carrying_charges_attributable) :
  imputed_interest_163_b c ≤ c.carrying_charges_attributable := by
  unfold imputed_interest_163_b;
  grind

/-
Theorem: Imputed interest is non-negative, provided carrying charges and unpaid balances are non-negative.
-/
theorem imputed_interest_nonnegative (c : Contract)
  (h_charges : 0 ≤ c.carrying_charges_attributable)
  (h_balances : ∀ b ∈ c.unpaid_balances, 0 ≤ b) :
  0 ≤ imputed_interest_163_b c := by
  unfold imputed_interest_163_b;
  unfold average_unpaid_balance at *; aesop;
  -- By induction on the list, we can show that the sum of the unpaid balances is non-negative.
  have h_sum_nonneg : ∀ (l : List Currency), (∀ b ∈ l, 0 ≤ b) → 0 ≤ List.foldl (fun x1 x2 => x1 + x2) 0 l := by
    intro l hl; induction' l using List.reverseRecOn with l ih <;> aesop;
    exact add_nonneg a ( hl _ ( Or.inr rfl ) );
  exact Int.ediv_nonneg ( Int.mul_nonneg ( Int.ediv_nonneg ( h_sum_nonneg _ h_balances ) ( by decide ) ) ( by decide ) ) ( by decide )

/-
Theorem: The allowed investment interest deduction does not exceed the net investment income (floored at 0).
-/
theorem investment_interest_limit_respects_net_income (ctx : InvestmentContext) :
  allowed_investment_interest ctx ≤ max 0 (net_investment_income ctx) := by
  exact min_le_right _ _

/-
Theorem: The allowed investment interest deduction does not exceed the total investment interest (paid + carryforward).
-/
theorem investment_interest_limit_respects_total (ctx : InvestmentContext) :
  allowed_investment_interest ctx ≤ ctx.interest_paid_allocable_to_investment + ctx.disallowed_interest_carryforward := by
  exact min_le_left _ _

/-
Theorem: The disallowed investment interest carryforward is always non-negative.
-/
theorem carryforward_nonnegative (ctx : InvestmentContext) :
  0 ≤ disallowed_investment_interest_carryforward ctx := by
  exact sub_nonneg_of_le ( min_le_of_left_le ( by norm_num ) )

/-
Defines a Taxpayer163 structure to aggregate all interest sources and a function to calculate the total allowed deduction.
-/
structure Taxpayer163 where
  -- 163(b) contracts
  contracts : List Contract
  
  -- 163(d) investment interest
  investment_context : InvestmentContext
  
  -- 163(c) redeemable ground rents
  ground_rents : List Currency
  
  -- 163(a) other interest (general rule, assuming fully deductible if not limited elsewhere)
  other_interest : Currency
  deriving DecidableEq, Repr

/--
Calculates the total interest deduction allowed under the formalized subsections of IRC §163.
Includes:
- Imputed interest from installment purchases (163(b))
- Redeemable ground rents (163(c))
- Allowed investment interest (163(d))
- Other general interest (163(a))
-/
def total_allowed_interest_deduction (t : Taxpayer163) : Currency :=
  let interest_b := t.contracts.foldl (fun sum c => sum + imputed_interest_163_b c) 0
  let interest_c := t.ground_rents.foldl (fun sum r => sum + redeemable_ground_rents_interest r) 0
  let interest_d := allowed_investment_interest t.investment_context
  let interest_a := t.other_interest
  interest_b + interest_c + interest_d + interest_a

/-
Theorem: The total allowed interest deduction is non-negative, provided all input amounts are non-negative.
-/
theorem total_allowed_interest_deduction_nonnegative (t : Taxpayer163)
  (h_contracts_charges : ∀ c ∈ t.contracts, 0 ≤ c.carrying_charges_attributable)
  (h_contracts_balances : ∀ c ∈ t.contracts, ∀ b ∈ c.unpaid_balances, 0 ≤ b)
  (h_ground_rents : ∀ r ∈ t.ground_rents, 0 ≤ r)
  (h_inv_interest : 0 ≤ t.investment_context.interest_paid_allocable_to_investment)
  (h_inv_carry : 0 ≤ t.investment_context.disallowed_interest_carryforward)
  (h_other : 0 ≤ t.other_interest) :
  0 ≤ total_allowed_interest_deduction t := by
  -- Show that the sum of all components in the terms is non-negative.
  apply add_nonneg;
  · refine' add_nonneg ( add_nonneg _ _ ) _;
    · -- Each term in the sum is non-negative by the provided hypotheses.
      have h_imputed_nonneg : ∀ c ∈ t.contracts, 0 ≤ imputed_interest_163_b c := by
        exact?;
      have h_sum_nonneg : ∀ {l : List Contract}, (∀ c ∈ l, 0 ≤ imputed_interest_163_b c) → 0 ≤ List.foldl (fun sum c => sum + imputed_interest_163_b c) 0 l := by
        intro l hl; induction' l using List.reverseRecOn with l ih <;> aesop;
        exact add_nonneg a ( hl _ ( Or.inr rfl ) );
      exact h_sum_nonneg h_imputed_nonneg;
    · have h_ground_rents_nonneg : ∀ (rs : List Currency), (∀ r ∈ rs, 0 ≤ r) → 0 ≤ List.foldl (fun sum r => sum + r) 0 rs := by
        intro rs hrs; induction' rs using List.reverseRecOn with rs ih <;> aesop;
        exact add_nonneg a ( hrs _ ( Or.inr rfl ) );
      convert h_ground_rents_nonneg t.ground_rents h_ground_rents using 1;
    · exact le_min ( by linarith ) ( by exact le_max_of_le_left ( by linarith ) );
  · assumption
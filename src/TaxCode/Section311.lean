/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7141f917-fce8-4e2d-9ec1-949f22d504e9
-/

/-
Formalization of IRC Section 311 (Taxability of corporation on distribution).
This module defines the necessary types (Currency, TaxYear, FilingStatus, Property, etc.) and implements the calculation logic for recognized gain and loss under Section 311.
It includes theorems verifying that:
1. Recognized gain is always non-negative.
2. Recognized loss is always zero (Section 311(a)).
3. The gain calculation correctly follows the formula FMV - Basis for appreciated property (Section 311(b)).
Examples are provided to demonstrate the calculations.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions for Currency, TaxYear, FilingStatus, Property, Corporation, Shareholder, and Distribution as required for IRC Section 311. Using `abbrev` for Currency to avoid instance synthesis issues.
-/
-- Common definitions
abbrev Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

-- Basic entities for Section 311
structure Property where
  fairMarketValue : Currency
  adjustedBasis : Currency
  isObligationOfCorporation : Bool -- To handle 311(b)(1)(A) exception
  deriving DecidableEq, Repr

structure Corporation where
  id : String
  deriving DecidableEq, Repr

structure Shareholder where
  id : String
  deriving DecidableEq, Repr

-- Represents a distribution event
structure Distribution where
  corporation : Corporation
  shareholder : Shareholder
  property : Property
  isCompleteLiquidation : Bool -- To handle 311(a) exception
  deriving DecidableEq, Repr

/-
Definitions for PropertyType and CalculationInput. Implementation of calculateRecognizedGain and calculateRecognizedLoss based on IRC §311.
-/
inductive PropertyType
  | Stock
  | RightsToAcquireStock
  | ObligationOfCorporation
  | PartnershipInterest
  | TrustInterest
  | OtherProperty
  deriving DecidableEq, Repr

structure CalculationInput where
  distribution : Distribution
  liabilityAssumed : Currency
  propertyType : PropertyType
  deriving DecidableEq, Repr

-- IRC §311(b)(2) refers to §336(b)
-- "the fair market value of such property shall be treated as not less than the amount of such liability."
def calculateDeemedFMV (fmv : Currency) (liability : Currency) : Currency :=
  if liability > fmv then liability else fmv

-- IRC §311(a) and (b)
def calculateRecognizedGain (input : CalculationInput) : Currency :=
  if input.distribution.isCompleteLiquidation then
    0 -- Section 311 does not apply to complete liquidations
  else
    match input.propertyType with
    | .Stock => 0 -- 311(a)(1)
    | .RightsToAcquireStock => 0 -- 311(a)(1)
    | .ObligationOfCorporation => 0 -- 311(b)(1)(A) exception
    | _ => -- 311(b)(1) applies to "property"
      let fmv := input.distribution.property.fairMarketValue
      let basis := input.distribution.property.adjustedBasis
      let deemedFMV := calculateDeemedFMV fmv input.liabilityAssumed
      if deemedFMV > basis then
        deemedFMV - basis
      else
        0

-- IRC §311(a) - No loss shall be recognized
def calculateRecognizedLoss (input : CalculationInput) : Currency :=
  0

/-
Theorem stating that the recognized gain is always non-negative.
-/
theorem gain_non_negative (input : CalculationInput) :
  calculateRecognizedGain input ≥ 0 := by
  unfold calculateRecognizedGain; aesop;
  linarith

/-
Theorem stating that the recognized loss is always zero, as per IRC §311(a).
-/
theorem loss_is_always_zero (input : CalculationInput) :
  calculateRecognizedLoss input = 0 := by
  exact?

/-
Theorem stating that for a non-liquidating distribution of appreciated property (other than stock/obligations) with no liabilities assumed, and non-negative FMV/basis, the recognized gain is FMV minus adjusted basis.
-/
theorem gain_formula_correct (input : CalculationInput)
  (h_not_liq : ¬input.distribution.isCompleteLiquidation)
  (h_prop : input.propertyType = .OtherProperty)
  (h_liab : input.liabilityAssumed = 0)
  (h_appr : input.distribution.property.fairMarketValue > input.distribution.property.adjustedBasis)
  (h_fmv_nonneg : input.distribution.property.fairMarketValue ≥ 0)
  (h_basis_nonneg : input.distribution.property.adjustedBasis ≥ 0) :
  calculateRecognizedGain input = input.distribution.property.fairMarketValue - input.distribution.property.adjustedBasis := by
  unfold calculateRecognizedGain; aesop;
  · unfold calculateDeemedFMV; aesop;
  · unfold calculateDeemedFMV at h ; aesop;
    · grind;
    · linarith

/-
Examples of calculating recognized gain for appreciated property, depreciated property, and property with liability in excess of FMV.
-/
-- Examples
def exampleDistribution : Distribution := {
  corporation := { id := "CorpA" },
  shareholder := { id := "ShareholderX" },
  property := { fairMarketValue := 100, adjustedBasis := 50, isObligationOfCorporation := false },
  isCompleteLiquidation := false
}

def exampleInputAppreciated : CalculationInput := {
  distribution := exampleDistribution,
  liabilityAssumed := 0,
  propertyType := .OtherProperty
}

#eval calculateRecognizedGain exampleInputAppreciated -- Expected: 50

def exampleInputDepreciated : CalculationInput := {
  distribution := { exampleDistribution with property := { fairMarketValue := 50, adjustedBasis := 100, isObligationOfCorporation := false } },
  liabilityAssumed := 0,
  propertyType := .OtherProperty
}

#eval calculateRecognizedGain exampleInputDepreciated -- Expected: 0

def exampleInputLiability : CalculationInput := {
  distribution := exampleDistribution,
  liabilityAssumed := 120, -- Liability > FMV (100)
  propertyType := .OtherProperty
}

#eval calculateRecognizedGain exampleInputLiability -- Expected: 120 - 50 = 70
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 75ecd939-33af-4ede-acf1-d98e6eba153c
-/

/-
Formalization of IRC Section 1015: Basis of property acquired by gifts and transfers in trust.

This module defines the necessary data structures (TaxYear, FilingStatus, Date, GiftInfo, TrustInfo, AdjustedBasis) and implements the basis calculation logic for gifts and transfers in trust as specified in IRC §1015(a)-(d).

Key features:
- `calc_basis_gift`: Calculates the basis for property acquired by gift, handling the dual basis rule for losses and the basis increase for gift tax paid.
- `calc_basis_trust`: Calculates the basis for property acquired by transfer in trust.
- Theorems verifying the correctness of the logic, such as `gift_basis_loss_le_gain` and `gift_tax_adjustment_capped_at_fmv`.
- Example theorems demonstrating the application of the rules in specific scenarios.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Common definitions for IRC Section 1015 formalization.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Define Date structure, helper dates, and GiftInfo structure. Added Repr instance for Currency to fix previous error.
-/
structure Date where
  year : Nat
  month : Nat
  day : Nat
  deriving DecidableEq, Repr, Ord

def Date.le (d1 d2 : Date) : Bool :=
  if d1.year < d2.year then true
  else if d1.year > d2.year then false
  else if d1.month < d2.month then true
  else if d1.month > d2.month then false
  else d1.day <= d2.day

instance : LE Date := ⟨fun d1 d2 => Date.le d1 d2⟩
instance : LT Date := ⟨fun d1 d2 => ¬(Date.le d2 d1)⟩

instance : Repr Currency := inferInstanceAs (Repr Int)

-- Helper for specific dates mentioned in the statute
def date_1920_12_31 : Date := { year := 1920, month := 12, day := 31 }
def date_1958_09_02 : Date := { year := 1958, month := 9, day := 2 }

structure GiftInfo where
  dateOfGift : Date
  donorBasis : Currency
  fmvAtGift : Currency
  giftTaxPaid : Currency
  deriving DecidableEq, Repr

/-
Add instances for Currency (CommRing, LinearOrder, Div, OfNat). Define AdjustedBasis and TrustInfo structures. Implement calculation functions for gift tax allocation, gift basis, and trust basis.
-/
instance : CommRing Currency := inferInstanceAs (CommRing Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance {n} : OfNat Currency n := inferInstanceAs (OfNat Int n)

structure AdjustedBasis where
  gainBasis : Currency
  lossBasis : Currency
  deriving DecidableEq, Repr

structure TrustInfo where
  dateOfTransfer : Date
  grantorBasis : Currency
  fmvAtTransfer : Currency
  gainRecognized : Currency
  lossRecognized : Currency
  deriving DecidableEq, Repr

-- IRC §1015(d)(2) Calculation of amount of tax paid with respect to gift
def calculate_allocated_gift_tax 
  (totalGiftTax : Currency)
  (amountOfGift : Currency)
  (taxableGifts : Currency)
  : Currency :=
  if taxableGifts = 0 then 0
  else (totalGiftTax * amountOfGift) / taxableGifts

-- Helper to apply the limitation from §1015(d)(1)
def apply_gift_tax_increase (basis : Currency) (fmv : Currency) (tax : Currency) : Currency :=
  if basis < fmv then
    min (basis + tax) fmv
  else
    basis

-- IRC §1015(a), (c), (d)
def calc_basis_gift (info : GiftInfo) : AdjustedBasis :=
  if info.dateOfGift <= date_1920_12_31 then
    -- §1015(c): Gift before Jan 1, 1921
    { gainBasis := info.fmvAtGift, lossBasis := info.fmvAtGift }
  else
    -- §1015(a): Gift after Dec 31, 1920
    let basisGain := info.donorBasis
    let basisLoss := if info.donorBasis > info.fmvAtGift then info.fmvAtGift else info.donorBasis
    
    -- §1015(d): Increased basis for gift tax paid
    let tax := info.giftTaxPaid
    let basisGainAdjusted := apply_gift_tax_increase basisGain info.fmvAtGift tax
    let basisLossAdjusted := apply_gift_tax_increase basisLoss info.fmvAtGift tax
    
    { gainBasis := basisGainAdjusted, lossBasis := basisLossAdjusted }

-- IRC §1015(b), (c)
def calc_basis_trust (info : TrustInfo) : AdjustedBasis :=
  if info.dateOfTransfer <= date_1920_12_31 then
    -- §1015(c): Transfer in trust before Jan 1, 1921
    { gainBasis := info.fmvAtTransfer, lossBasis := info.fmvAtTransfer }
  else
    -- §1015(b): Transfer in trust after Dec 31, 1920
    let basis := info.grantorBasis + info.gainRecognized - info.lossRecognized
    { gainBasis := basis, lossBasis := basis }

/-
Theorem: For gifts, the basis for determining loss is always less than or equal to the basis for determining gain.
-/
theorem gift_basis_loss_le_gain (info : GiftInfo) :
  (calc_basis_gift info).lossBasis ≤ (calc_basis_gift info).gainBasis := by
  unfold calc_basis_gift;
  split_ifs <;> norm_num [ apply_gift_tax_increase ];
  bound;
  exact?

/-
Theorem: For transfers in trust (not by gift), the basis for gain and loss is the same.
-/
theorem trust_basis_gain_eq_loss (info : TrustInfo) :
  (calc_basis_trust info).gainBasis = (calc_basis_trust info).lossBasis := by
  unfold calc_basis_trust; aesop;

/-
Theorem: The gift tax adjustment never increases the basis above the Fair Market Value (FMV) if the original basis was less than FMV.
-/
theorem gift_tax_adjustment_capped_at_fmv (basis fmv tax : Currency) (h : basis < fmv) :
  apply_gift_tax_increase basis fmv tax ≤ fmv := by
  unfold apply_gift_tax_increase; aesop;

/-
Theorem: If the donor's basis is greater than or equal to FMV, the gift tax adjustment does not change the basis.
-/
theorem gift_tax_no_increase_if_basis_gt_fmv (basis fmv tax : Currency) (h : basis ≥ fmv) :
  apply_gift_tax_increase basis fmv tax = basis := by
  -- By definition of `apply_gift_tax_increase`, if `basis ≥ fmv`, then `apply_gift_tax_increase basis fmv tax = basis`.
  simp [apply_gift_tax_increase, h]

/-
Theorem: Consistency check: If donor basis equals FMV, gain and loss basis are equal.
-/
theorem gift_basis_eq_if_donor_eq_fmv (info : GiftInfo) (h : info.donorBasis = info.fmvAtGift) :
  (calc_basis_gift info).gainBasis = (calc_basis_gift info).lossBasis := by
  unfold calc_basis_gift; aesop;

/-
Provide examples as theorems to demonstrate the functionality of the implemented basis calculation functions, replacing #eval which is not supported.
-/
-- Example 1: Gift after 1920, Gain scenario
-- Donor Basis: 1000, FMV: 1500, Tax Paid: 0
-- Expect Gain Basis: 1000, Loss Basis: 1000
theorem example_1_gift_gain :
  calc_basis_gift {
    dateOfGift := { year := 2020, month := 1, day := 1 },
    donorBasis := 1000,
    fmvAtGift := 1500,
    giftTaxPaid := 0
  } = { gainBasis := 1000, lossBasis := 1000 } := by
          unfold calc_basis_gift; norm_num;
          bound;
          cases h

-- Example 2: Gift after 1920, Loss scenario
-- Donor Basis: 2000, FMV: 1500, Tax Paid: 0
-- Expect Gain Basis: 2000, Loss Basis: 1500
theorem example_2_gift_loss :
  calc_basis_gift {
    dateOfGift := { year := 2020, month := 1, day := 1 },
    donorBasis := 2000,
    fmvAtGift := 1500,
    giftTaxPaid := 0
  } = { gainBasis := 2000, lossBasis := 1500 } := by
          -- Let's calculate the basis for the gift using the provided information.
          simp [calc_basis_gift, apply_gift_tax_increase];
          split_ifs <;> norm_cast

-- Example 3: Gift with Tax Adjustment (d)(1)
-- Donor Basis: 1000, FMV: 1500, Tax Paid: 200
-- Expect Gain Basis: 1200, Loss Basis: 1200
theorem example_3_gift_tax :
  calc_basis_gift {
    dateOfGift := { year := 2020, month := 1, day := 1 },
    donorBasis := 1000,
    fmvAtGift := 1500,
    giftTaxPaid := 200
  } = { gainBasis := 1200, lossBasis := 1200 } := by
          unfold calc_basis_gift;
          bound;
          cases h

-- Example 4: Gift with Tax Adjustment Capped at FMV
-- Donor Basis: 1000, FMV: 1500, Tax Paid: 600
-- Expect Gain Basis: 1500 (capped), Loss Basis: 1500
theorem example_4_gift_tax_capped :
  calc_basis_gift {
    dateOfGift := { year := 2020, month := 1, day := 1 },
    donorBasis := 1000,
    fmvAtGift := 1500,
    giftTaxPaid := 600
  } = { gainBasis := 1500, lossBasis := 1500 } := by
          -- By definition of `calc_basis_gift`, we know that if the date of gift is after Dec 31, 1920, the basis is adjusted for the gift tax.
          simp [calc_basis_gift];
          -- Let's simplify the goal. Since we have a contradiction assumption, the goal should be false.
          aesop

-- Example 5: Transfer in Trust
-- Grantor Basis: 1000, Gain Recognized: 100, Loss Recognized: 0
-- Expect Basis: 1100
theorem example_5_trust :
  calc_basis_trust {
    dateOfTransfer := { year := 2020, month := 1, day := 1 },
    grantorBasis := 1000,
    fmvAtTransfer := 1500,
    gainRecognized := 100,
    lossRecognized := 0
  } = { gainBasis := 1100, lossBasis := 1100 } := by
          exact if_neg ( by exact fun h => by contradiction )

/-
Implement helper for IRC §1015(d)(3) regarding split gifts, and a trivial theorem confirming it sums the taxes.
-/
-- IRC §1015(d)(3) Gifts treated as made one-half by each spouse
-- If a gift is split between spouses, the gift tax paid is the sum of tax paid by each.
def calculate_split_gift_tax (taxPaidByDonor : Currency) (taxPaidBySpouse : Currency) : Currency :=
  taxPaidByDonor + taxPaidBySpouse

theorem split_gift_tax_additive (t1 t2 : Currency) :
  calculate_split_gift_tax t1 t2 = t1 + t2 := by
  rfl
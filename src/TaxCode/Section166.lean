/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 035243a0-cbe4-49b0-aa3a-f39108c3134f
-/

/-
Formalization of IRC Section 166 (Bad Debts).

This module defines the data structures and logic for calculating deductions for bad debts
under 26 U.S. Code § 166. It covers:
- Wholly worthless debts (§166(a)(1))
- Partially worthless debts (§166(a)(2))
- Nonbusiness debts (§166(d))
- Worthless securities (§166(e))

The main function is `calculate_deduction`, which takes a `Debt` structure and returns a
`DeductionResult`. Several theorems are proved to verify the correctness of the implementation
against the legal requirements.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define Currency, TaxYear, and FilingStatus as requested.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

/-
Define DeductionType, DeductionResult, and Debt structures, adding Repr instance for Currency first.
-/
instance : Repr Currency := inferInstanceAs (Repr Int)

inductive DeductionType
  | None
  | Ordinary
  | ShortTermCapitalLoss
  deriving DecidableEq, Repr

structure DeductionResult where
  amount : Currency
  type : DeductionType
  deriving DecidableEq, Repr

structure Debt where
  adjusted_basis : Currency
  recoverable_amount : Currency
  amount_charged_off : Currency
  is_business_debt : Bool
  is_security : Bool
  became_worthless_this_year : Bool
  deriving DecidableEq, Repr

/-
Define instances for Currency and implement calculate_deduction.
-/
instance (n : Nat) : OfNat Currency n := ⟨(n : Int)⟩
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Min Currency := inferInstanceAs (Min Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : DecidableRel (· < · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· < · : Int → Int → Prop))
instance : DecidableRel (· ≤ · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· ≤ · : Int → Int → Prop))

def calculate_deduction (d : Debt) : DeductionResult :=
  if d.is_security then
    { amount := 0, type := DeductionType.None } -- IRC §166(e)
  else if d.is_business_debt then
    if d.became_worthless_this_year then
      -- IRC §166(a)(1): Wholly worthless debts
      { amount := d.adjusted_basis, type := DeductionType.Ordinary }
    else
      -- IRC §166(a)(2): Partially worthless debts
      -- Deduction is allowed up to the amount charged off, but cannot exceed the actual loss
      let actual_loss := d.adjusted_basis - d.recoverable_amount
      let deduction := min actual_loss d.amount_charged_off
      if deduction > 0 then
        { amount := deduction, type := DeductionType.Ordinary }
      else
        { amount := 0, type := DeductionType.None }
  else
    -- IRC §166(d): Nonbusiness debts
    if d.became_worthless_this_year then
      -- IRC §166(d)(1)(B): Treated as short-term capital loss
      { amount := d.adjusted_basis, type := DeductionType.ShortTermCapitalLoss }
    else
      -- Partial worthlessness not allowed for nonbusiness debts
      { amount := 0, type := DeductionType.None }

/-
Theorem: The deduction amount is always non-negative, assuming adjusted basis is non-negative.
-/
theorem deduction_nonnegative (d : Debt) (h_basis : d.adjusted_basis ≥ 0) :
  (calculate_deduction d).amount ≥ 0 := by
    unfold calculate_deduction; aesop;
    · bound;
    · bound

/-
Theorem: Debts evidenced by a security result in 0 deduction under this section.
-/
theorem security_deduction_zero (d : Debt) (h : d.is_security) :
  (calculate_deduction d).amount = 0 := by
    simp +decide [ *, calculate_deduction ]

/-
Theorem: Nonbusiness debts that become worthless in the taxable year result in a ShortTermCapitalLoss deduction type (assuming not a security).
-/
theorem nonbusiness_worthless_is_short_term_capital_loss (d : Debt)
  (h_nonbusiness : ¬d.is_business_debt)
  (h_worthless : d.became_worthless_this_year)
  (h_security : ¬d.is_security) :
  (calculate_deduction d).type = DeductionType.ShortTermCapitalLoss := by
  unfold calculate_deduction
  simp [h_nonbusiness, h_worthless, h_security]

/-
Theorem: For a partially worthless business debt, the deduction amount does not exceed the amount charged off (assuming charged off amount is non-negative).
-/
theorem partial_business_deduction_limit (d : Debt)
  (h_business : d.is_business_debt)
  (h_partial : ¬d.became_worthless_this_year)
  (h_security : ¬d.is_security)
  (h_charged_off_nonneg : d.amount_charged_off ≥ 0) :
  (calculate_deduction d).amount ≤ d.amount_charged_off := by
  unfold calculate_deduction
  simp [h_business, h_partial, h_security]
  split
  · apply min_le_right
  · simp; exact h_charged_off_nonneg
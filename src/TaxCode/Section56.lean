/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f2345928-0c76-40a6-9eeb-5dfeb16c39d0
-/

/-
Formalization of IRC Section 56 (Adjustments in computing alternative minimum taxable income).
Covers §56(a)(1) Depreciation, §56(a)(2) Mining exploration and development costs, and §56(a)(3) Treatment of certain long-term contracts.
Includes type definitions, executable calculation functions, and theorems verifying key properties.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic types for IRC Section 56 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

/-
Definitions for Date and Property to support depreciation calculations. Removed Repr derivation for Property to avoid issues.
-/
structure Date where
  year : Nat
  month : Nat
  day : Nat
  deriving DecidableEq, Repr, Inhabited

def Date.le (d1 d2 : Date) : Bool :=
  if d1.year < d2.year then true
  else if d1.year > d2.year then false
  else if d1.month < d2.month then true
  else if d1.month > d2.month then false
  else d1.day <= d2.day

instance : LE Date where
  le d1 d2 := Date.le d1 d2

inductive PropertyType
  | Personal
  | Real
  | Section1250
  | Other
  deriving DecidableEq, Repr

structure Property where
  id : String
  type : PropertyType
  placedInService : Date
  costBasis : Currency
  recoveryPeriod : Nat -- in years
  is_168f_excluded : Bool -- Excluded by 168(f)
  is_168e3Civ : Bool -- Described in 168(e)(3)(C)(iv)
  deriving DecidableEq

/-
Defining basic typeclass instances for Currency (Int) to support arithmetic and literals. Avoiding mixed instances to prevent synthesis errors.
-/
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)

instance (n : Nat) : OfNat Currency n where
  ofNat := (n : Int)

def Nat.toCurrency (n : Nat) : Currency := (n : Int)

/-
Defining AMTDeductionResult and depreciation calculation helpers.
Using Nat.toCurrency to ensure type compatibility for arithmetic operations.
calculateSL: Straight Line depreciation.
calculate150DB: 150% Declining Balance.
-/
inductive AMTDeductionResult
  | Amount (c : Currency)
  | UseRegularTax
  deriving DecidableEq, Repr

def calculateSL (basis : Currency) (remainingLife : Nat) : Currency :=
  if remainingLife == 0 then 0 else basis / Nat.toCurrency remainingLife

def calculate150DB (basis : Currency) (recoveryPeriod : Nat) : Currency :=
  if recoveryPeriod == 0 then 0 else (basis * Nat.toCurrency 150) / (Nat.toCurrency recoveryPeriod * Nat.toCurrency 100)

/-
Implementation of the depreciation schedule using structural recursion on the number of years remaining (fuel).
Also implements `calculateAMTDepreciation` which handles the exclusions and date checks, and calls the schedule generator.
IRC §56(a)(1)(A).
-/
def depreciationScheduleAux (fuel : Nat) (currentBasis : Currency) (switched : Bool) (p : Property) (currentYear : Nat) : List Currency :=
  match fuel with
  | 0 => []
  | n + 1 =>
    let remainingLife := p.recoveryPeriod - currentYear + 1
    if remainingLife == 0 then []
    else
      let deduction :=
        if switched || p.type == .Section1250 then
          calculateSL currentBasis remainingLife
        else
          let db := calculate150DB currentBasis p.recoveryPeriod
          let sl := calculateSL currentBasis remainingLife
          if sl >= db then sl else db
      
      let newSwitched := switched || (deduction == calculateSL currentBasis remainingLife && p.type != .Section1250)
      
      deduction :: depreciationScheduleAux n (currentBasis - deduction) newSwitched p (currentYear + 1)

def calculateAMTDepreciation (p : Property) : List AMTDeductionResult :=
  if p.is_168f_excluded || p.is_168e3Civ then
    List.replicate p.recoveryPeriod AMTDeductionResult.UseRegularTax
  else
    let cutoffDate := { year := 1986, month := 12, day := 31 : Date }
    if p.placedInService <= cutoffDate then
       List.replicate p.recoveryPeriod AMTDeductionResult.UseRegularTax
    else
       let schedule := depreciationScheduleAux p.recoveryPeriod p.costBasis false p 1
       schedule.map AMTDeductionResult.Amount

/-
Implementation of IRC §56(a)(2) for Mining exploration and development costs.
Costs are capitalized and amortized ratably over a 10-year period.
Returns the allowable AMT deduction for a given year.
-/
structure MiningCost where
  cost : Currency
  yearIncurred : Nat
  deriving DecidableEq, Repr

def calculateAMTMiningDeduction (mc : MiningCost) (currentYear : Nat) : Currency :=
  let startYear := mc.yearIncurred
  let endYear := startYear + 9 -- 10-year period: year 0 to year 9
  if currentYear >= startYear && currentYear <= endYear then
    mc.cost / Nat.toCurrency 10
  else
    0

/-
Implementation of IRC §56(a)(3) for Long-term contracts.
Calculates taxable income using the percentage of completion method for contracts entered into on or after March 1, 1986.
Formula: (CostsIncurred / TotalEstimatedCost) * TotalPrice - PreviousIncome.
-/
structure LongTermContract where
  id : String
  contractDate : Date
  totalContractPrice : Currency
  totalEstimatedCost : Currency
  costsIncurredToDate : Currency
  previousIncomeRecognized : Currency
  deriving DecidableEq, Repr

def calculateAMTContractIncome (c : LongTermContract) : Currency :=
  let cutoffDate := { year := 1986, month := 3, day := 1 : Date }
  if c.contractDate >= cutoffDate then
    -- Percentage of Completion Method (simplified representation of 460(b))
    -- Income = (CostsIncurred / TotalEstimatedCost) * TotalPrice - PreviousIncome
    if c.totalEstimatedCost == 0 then 0
    else
      let completionRatioNum := c.costsIncurredToDate
      let completionRatioDenom := c.totalEstimatedCost
      -- We need to do the multiplication first to maintain precision with integer arithmetic
      -- (CostsIncurred * TotalPrice) / TotalEstimatedCost
      let cumulativeIncome := (completionRatioNum * c.totalContractPrice) / completionRatioDenom
      cumulativeIncome - c.previousIncomeRecognized
  else
    -- Pre-March 1, 1986 contracts are not subject to this specific AMT adjustment in this paragraph
    -- Returning 0 implies no *adjustment* or that this function only calculates the AMT income for affected contracts.
    -- However, the prompt asks for "taxable income from such contract shall be determined..."
    -- If it's not affected, it follows regular tax rules, which we don't have.
    -- I will return 0 and document that this function returns the AMT income *adjustment* or specific AMT income for affected contracts.
    -- Actually, the text says "taxable income ... shall be determined".
    -- I'll assume for non-affected contracts, we don't calculate it here (or return 0 as a placeholder for "no change" or "handled elsewhere").
    0

/-
Theorem: For any year within the 10-year amortization period, the mining deduction is equal to 10% of the cost (calculated as cost / 10).
-/
theorem mining_deduction_is_10_percent (mc : MiningCost) (year : Nat) :
  year >= mc.yearIncurred ∧ year <= mc.yearIncurred + 9 →
  calculateAMTMiningDeduction mc year = mc.cost / Nat.toCurrency 10 := by
  unfold calculateAMTMiningDeduction; aesop;

/-
Theorem: The length of the depreciation schedule generated by `depreciationScheduleAux` is equal to the `fuel` parameter.
Theorem: The length of the AMT depreciation schedule returned by `calculateAMTDepreciation` is equal to the property's recovery period.
-/
theorem depreciation_schedule_length (fuel : Nat) (basis : Currency) (switched : Bool) (p : Property) (year : Nat) :
  (depreciationScheduleAux fuel basis switched p year).length = fuel := by
    induction' fuel with fuel ih generalizing basis switched p year <;> simp_all! +arith +decide;
    aesop;
    · cases switched <;> aesop;
    · grind;
    · cases eq_or_ne ( calculate150DB basis p.recoveryPeriod ) ( calculateSL basis ( p.recoveryPeriod - year + 1 ) ) <;> aesop;
      · grind;
      · grind

theorem amt_depreciation_length (p : Property) :
  (calculateAMTDepreciation p).length = p.recoveryPeriod := by
    unfold calculateAMTDepreciation;
    aesop;
    exact?

/-
Defining example data for Property, MiningCost, and LongTermContract.
Adding a test theorem to verify the mining deduction calculation for the example data.
This replaces the `#eval` requests which were causing tool errors.
-/
-- Example Data Definitions

def exampleProperty : Property := {
  id := "Prop1",
  type := PropertyType.Personal,
  placedInService := { year := 2020, month := 1, day := 1 },
  costBasis := Nat.toCurrency 10000,
  recoveryPeriod := 5,
  is_168f_excluded := false,
  is_168e3Civ := false
}

def exampleMiningCost : MiningCost := {
  cost := Nat.toCurrency 100000,
  yearIncurred := 2023
}

def exampleContract : LongTermContract := {
  id := "Contract1",
  contractDate := { year := 2024, month := 6, day := 1 },
  totalContractPrice := Nat.toCurrency 500000,
  totalEstimatedCost := Nat.toCurrency 400000,
  costsIncurredToDate := Nat.toCurrency 200000, -- 50% complete
  previousIncomeRecognized := Nat.toCurrency 0
}

-- Test Theorem for Mining Deduction
theorem example_mining_deduction_check :
  calculateAMTMiningDeduction exampleMiningCost 2024 = Nat.toCurrency 10000 := by
  rfl

/-
Test theorem verifying the AMT contract income calculation for the example contract.
Expected result: (200,000 / 400,000) * 500,000 - 0 = 250,000.
-/
theorem example_contract_income_check :
  calculateAMTContractIncome exampleContract = Nat.toCurrency 250000 := by
  unfold calculateAMTContractIncome;
  aesop;
  contrapose! h; aesop
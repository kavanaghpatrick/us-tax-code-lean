/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1f604098-fb90-48ce-b1cd-45d5e3cc1562
-/

/-
Formalization of IRC Section 401(a) regarding qualified pension, profit-sharing, and stock bonus plans.
Includes definitions for TaxYear, FilingStatus, PlanType, Employer, Employee, and Plan.
Implements calculation functions for coverage (IRC §410(b)), nondiscrimination (IRC §401(a)(4)), and integrated defined benefit limits (IRC §401(a)(5)(D)).
Provides theorems verifying key properties of these calculations, such as coverage passing when all employees benefit and nondiscrimination passing when there are no highly compensated employees.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Currency is represented as an integer (cents).
-/
def Currency := Int

/-
A TaxYear is a natural number greater than or equal to 1913.
-/
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

/-
Filing status for tax purposes.
-/
inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

/-
Types of plans mentioned in IRC §401(a): stock bonus, pension, or profit-sharing.
-/
inductive PlanType
  | StockBonus
  | Pension
  | ProfitSharing
  deriving DecidableEq, Repr

/-
Structures for Employer and Employee, including relevant attributes for tax qualification.
-/
structure Employer where
  id : String
  deriving DecidableEq

structure Employee where
  id : String
  employer : Employer
  compensation : Currency
  is_highly_compensated : Bool -- As per 414(q)
  is_salaried : Bool -- For 401(a)(5)(A)
  years_of_service : Nat
  deriving DecidableEq

/-
Structure representing a pension, profit-sharing, or stock bonus plan.
-/
structure Plan where
  id : String
  type : PlanType
  employer : Employer
  employees : List Employee
  is_us_trust : Bool -- 401(a) "created or organized in the United States"
  exclusive_benefit : Bool -- 401(a) "exclusive benefit of his employees"
  contributions_made : Bool -- 401(a)(1)
  no_diversion : Bool -- 401(a)(2)
  satisfies_410 : Bool -- 401(a)(3)
  deriving DecidableEq

/-
Checks if a plan satisfies the minimum coverage requirements of IRC §410(b).
Test A: The plan benefits at least 70 percent of employees who are not highly compensated employees.
Test B: The plan benefits a percentage of non-highly compensated employees which is at least 70 percent of the percentage of highly compensated employees benefiting under the plan.
-/
def check_coverage_410 (participants : List Employee) (all_employees : List Employee) : Bool :=
  let non_hce := all_employees.filter (fun e => !e.is_highly_compensated)
  let hce := all_employees.filter (fun e => e.is_highly_compensated)
  let non_hce_benefiting := participants.filter (fun e => !e.is_highly_compensated)
  let hce_benefiting := participants.filter (fun e => e.is_highly_compensated)

  let non_hce_count := non_hce.length
  let hce_count := hce.length
  let non_hce_benefiting_count := non_hce_benefiting.length
  let hce_benefiting_count := hce_benefiting.length

  -- Test A: 70% of non-HCEs benefit
  let test_a := non_hce_count > 0 && (non_hce_benefiting_count * 100 >= non_hce_count * 70)

  -- Test B: Ratio percentage test
  -- % of non-HCE benefiting >= 70% of (% of HCE benefiting)
  -- (non_hce_benefiting / non_hce) >= 0.7 * (hce_benefiting / hce)
  -- non_hce_benefiting * hce * 100 >= 70 * hce_benefiting * non_hce
  let test_b :=
    if hce_count == 0 then true -- If no HCEs, ratio test is trivially satisfied or N/A (usually considered passed)
    else if non_hce_count == 0 then true -- If no non-HCEs, also passed
    else
      (non_hce_benefiting_count * hce_count * 100) >= (70 * hce_benefiting_count * non_hce_count)

  test_a || test_b

/-
Checks if the plan satisfies the nondiscrimination requirements of IRC §401(a)(4).
Calculates the average contribution rate for HCEs and non-HCEs and ensures HCEs do not have a higher average rate.
This is a simplified check corresponding to the General Test or Safe Harbor principles.
-/
def get_rate (e : Employee) (contribution : Currency) : Int :=
  let comp : Int := e.compensation
  let contrib : Int := contribution
  if comp == 0 then 0 else (contrib * 10000) / comp

-- DEPRECATED: Oversimplified average-based test (see GitHub issue #39)
-- This test can incorrectly pass discriminatory plans where HCEs get favorable treatment
-- Kept for backwards compatibility but should use check_nondiscrimination_safe_harbor instead
def check_nondiscrimination (participants : List Employee) (contribution_map : String -> Currency) : Bool :=
  let hce := participants.filter (fun e => e.is_highly_compensated)
  let non_hce := participants.filter (fun e => !e.is_highly_compensated)

  let hce_rates_sum : Int := hce.foldl (fun sum e =>
    let contrib : Int := contribution_map e.id
    sum + get_rate e contrib) 0
  let non_hce_rates_sum : Int := non_hce.foldl (fun sum e =>
    let contrib : Int := contribution_map e.id
    sum + get_rate e contrib) 0

  let avg_hce := if hce.length == 0 then 0 else hce_rates_sum / (hce.length : Int)
  let avg_non_hce := if non_hce.length == 0 then 0 else non_hce_rates_sum / (non_hce.length : Int)

  if non_hce.length == 0 || hce.length == 0 then true
  else avg_hce <= avg_non_hce

/-
IRC §401(a)(4) Safe Harbor: Uniform Percentage Test
Per Treas. Reg. § 1.401(a)(4)-2(b)(2), a plan satisfies nondiscrimination if all employees
receive the same percentage of compensation as contributions.
-/
def check_uniform_percentage_safe_harbor (participants : List Employee)
    (contribution_map : String -> Currency) : Bool :=
  if participants.length == 0 then true
  else
    let rates := participants.map (fun e => get_rate e (contribution_map e.id))
    match rates with
    | [] => true
    | first_rate :: rest => rest.all (fun r => r == first_rate)

/-
IRC §401(a)(4) Nondiscrimination Test with Safe Harbor
Implements proper nondiscrimination testing per Treas. Reg. § 1.401(a)(4).
Uses safe harbor test (uniform percentage) which is more rigorous than simple averages.
-/
def check_nondiscrimination_safe_harbor (participants : List Employee)
    (contribution_map : String -> Currency) : Bool :=
  check_uniform_percentage_safe_harbor participants contribution_map

/-
Determines if a plan is a qualified trust under IRC §401(a) by checking all subsections.
Includes checks for US trust, exclusive benefit, contributions, non-diversion, coverage (410), and nondiscrimination.
-/
def is_qualified_plan (plan : Plan) (all_employees : List Employee) (contribution_map : String -> Currency) : Bool :=
  -- 401(a) General requirements
  let basic_reqs := plan.is_us_trust && plan.exclusive_benefit

  -- 401(a)(1) Contributions made
  let contrib_req := plan.contributions_made

  -- 401(a)(2) No diversion
  let no_diversion_req := plan.no_diversion

  -- 401(a)(3) Coverage requirements (referencing 410)
  -- Note: The plan structure has a boolean `satisfies_410`, but we also have a calculation function.
  -- We should probably use the calculation function if we have the data, or rely on the flag if it's a property.
  -- The user asked to "Implement all calculation functions", so let's use the calculation.
  let coverage_req := check_coverage_410 plan.employees all_employees

  -- 401(a)(4) Nondiscrimination (using safe harbor test per Treas. Reg. § 1.401(a)(4))
  let nondiscrim_req := check_nondiscrimination_safe_harbor plan.employees contribution_map

  basic_reqs && contrib_req && no_diversion_req && coverage_req && nondiscrim_req

/-
Theorem: If the participants are exactly the set of all employees, the coverage test passes.
Proven by Aristotle using grind tactic.
-/
theorem coverage_passed_if_all_benefit (all_employees : List Employee)
  (h_non_empty : all_employees.length > 0) :
  check_coverage_410 all_employees all_employees = true := by
    unfold check_coverage_410
    simp only []
    -- When participants = all_employees, benefiting counts = total counts
    -- Test A: non_hce_count > 0 && (non_hce_count * 100 >= non_hce_count * 70) → true
    -- Test B: (non_hce_count * hce_count * 100) >= (70 * hce_count * non_hce_count) → true
    -- Since test_a || test_b, the result is true
    grind

/-
Theorem: If there are no highly compensated employees, the nondiscrimination test passes.
-/
theorem nondiscrimination_passed_if_no_hce (participants : List Employee) (contribution_map : String -> Currency)
  (h_no_hce : ∀ e ∈ participants, e.is_highly_compensated = false) :
  check_nondiscrimination participants contribution_map = true := by
    exact if_pos ( by aesop )

/-
Theorem: If a plan is qualified, it must have passed the coverage test.
-/
theorem qualified_implies_coverage (plan : Plan) (all_employees : List Employee) (contribution_map : String -> Currency)
  (h_qualified : is_qualified_plan plan all_employees contribution_map = true) :
  check_coverage_410 plan.employees all_employees = true := by
    unfold is_qualified_plan at h_qualified; aesop;

/-
Checks if the employer-derived benefit respects the integration limit (excess of final pay over federal benefit).
-/
def check_integrated_db_limit (final_pay : Currency) (federal_benefit : Currency) (employer_benefit : Currency) : Bool :=
  let fp : Int := final_pay
  let fb : Int := federal_benefit
  let eb : Int := employer_benefit
  let excess := fp - fb
  let limit := if excess < 0 then 0 else excess
  eb <= limit

/-
Calculates the integration limit (excess of final pay over federal benefit) as an integer.
-/
def calc_integrated_db_limit (final_pay : Currency) (federal_benefit : Currency) : Int :=
  let fp : Int := final_pay
  let fb : Int := federal_benefit
  let excess := fp - fb
  if excess < 0 then 0 else excess

/-
Theorem: The integration limit calculated for defined benefit plans is always non-negative.
-/
theorem integrated_db_limit_non_negative (final_pay : Currency) (federal_benefit : Currency) :
  calc_integrated_db_limit final_pay federal_benefit >= 0 := by
    unfold calc_integrated_db_limit; norm_num;
    split_ifs <;> linarith
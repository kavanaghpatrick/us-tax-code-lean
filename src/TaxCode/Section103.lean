/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 716f9923-f2d9-4d32-8085-acf1995d75a7
-/

/-
Formalization of IRC Section 103 regarding Interest on State and Local Bonds.

This module defines the necessary types and structures to represent bonds and their issuers,
and implements the logic to determine if interest on a bond is tax-exempt based on
IRC §103(a), (b), and (c).

Key definitions:
- `Bond`: Represents a bond with attributes like issuer, interest amount, and flags for
  private activity, qualified status, arbitrage, and registration.
- `isTaxExempt`: Determines if a bond's interest is excluded from gross income.
- `totalExcludedInterest`: Calculates the total tax-exempt interest for a list of bonds.
- `totalTaxableInterest`: Calculates the total taxable interest for a list of bonds.

The module also includes a theorem `interest_partition` which verifies that the total interest
is the sum of the excluded and taxable interest, ensuring the correctness of the classification logic.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for IRC Section 103 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions (inline these if needed)
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Definitions for Bond, Issuer, and State, along with functions to determine tax exemption status and calculate excluded/taxable interest under IRC §103.
-/
-- Provide instances for Currency (which is Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance {n : Nat} : OfNat Currency n := inferInstanceAs (OfNat Int n)
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : ToString Currency := inferInstanceAs (ToString Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)

-- IRC §103(c)(2) Definition of State
inductive StateDefinition
  | USState
  | DistrictOfColumbia
  | USPossession
  deriving DecidableEq, Repr

-- IRC §103(c)(1) Definition of State or local bond issuer
inductive Issuer
  | State (s : StateDefinition)
  | PoliticalSubdivision (parent : StateDefinition)
  | Other -- For non-state/local bonds (e.g. Federal, Corporate)
  deriving DecidableEq, Repr

-- Structure representing a Bond with attributes relevant to §103
structure Bond where
  issuer : Issuer
  interest : Currency
  isPrivateActivity : Bool -- IRC §103(b)(1) / §141
  isQualified : Bool       -- IRC §103(b)(1) / §141
  isArbitrage : Bool       -- IRC §103(b)(2) / §148
  isRegistered : Bool      -- IRC §103(b)(3) / §149
  deriving DecidableEq, Repr

-- Helper to identify State or Local Bond
-- IRC §103(c)(1)
def isStateOrLocalBond (b : Bond) : Bool :=
  match b.issuer with
  | Issuer.State _ => true
  | Issuer.PoliticalSubdivision _ => true
  | Issuer.Other => false

-- IRC §103(b) Exceptions to the exclusion
-- Returns true if the bond's interest is excluded from gross income
def isTaxExempt (b : Bond) : Bool :=
  if ¬ isStateOrLocalBond b then false
  else
    -- (b)(1) Private activity bond which is not a qualified bond
    let exception1 := b.isPrivateActivity ∧ ¬ b.isQualified
    -- (b)(2) Arbitrage bond
    let exception2 := b.isArbitrage
    -- (b)(3) Bond not in registered form
    let exception3 := ¬ b.isRegistered
    
    ¬ (exception1 ∨ exception2 ∨ exception3)

-- Calculation of total excluded interest for a list of bonds
def totalExcludedInterest (bonds : List Bond) : Currency :=
  (bonds.filter isTaxExempt).foldl (fun sum b => sum + b.interest) 0

-- Calculation of total taxable interest (included in gross income) for a list of bonds
def totalTaxableInterest (bonds : List Bond) : Currency :=
  (bonds.filter (fun b => ¬ isTaxExempt b)).foldl (fun sum b => sum + b.interest) 0

/-
Lemma stating that folding addition over a list of integers starting from 0 is equivalent to the sum of the list.
-/
theorem foldl_add_eq_sum (l : List Int) : l.foldl (· + ·) 0 = l.sum := by
  rw [ List.sum_eq_foldl ]

/-
Lemma stating that folding addition of bond interests over a list of bonds is equivalent to the sum of the mapped interests.
-/
theorem foldl_bond_interest_eq_sum_map (l : List Bond) : l.foldl (fun sum b => sum + b.interest) 0 = (l.map Bond.interest).sum := by
  convert foldl_add_eq_sum _ using 1;
  conv_rhs => rw [ List.foldl_map ] ;
  rfl

/-
General lemma: sum of mapped values over elements satisfying p plus sum over elements not satisfying p equals total sum.
-/
theorem sum_map_filter_partition {α : Type} (l : List α) (f : α → Int) (p : α → Bool) :
  ((l.filter p).map f).sum + ((l.filter (fun x => ¬p x)).map f).sum = (l.map f).sum := by
  induction l <;> aesop;
  grind +ring

/-
Theorem stating that the total interest is the sum of excluded and taxable interest, proved using helper lemmas.
-/
theorem interest_partition (bonds : List Bond) :
  totalExcludedInterest bonds + totalTaxableInterest bonds = (bonds.map Bond.interest).foldl (fun sum i => sum + i) 0 := by
  -- Apply `foldl_bond_interest_eq_sum_map` to rewrite the foldl expressions in `totalExcludedInterest` and `totalTaxableInterest`.
  have h_excl : (bonds.filter isTaxExempt).foldl (fun sum b => sum + b.interest) 0 = ((bonds.filter isTaxExempt).map Bond.interest).sum := by
    exact?
  have h_tax : (bonds.filter (fun b => ¬ isTaxExempt b)).foldl (fun sum b => sum + b.interest) 0 = ((bonds.filter (fun b => ¬ isTaxExempt b)).map Bond.interest).sum := by
    exact?;
  convert sum_map_filter_partition bonds ( fun b => b.interest ) isTaxExempt using 1;
  · congr! 1;
  · convert foldl_add_eq_sum _ using 1
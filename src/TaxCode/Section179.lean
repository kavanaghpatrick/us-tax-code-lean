/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2e604c5f-dfe0-4942-bebb-ac0618b5f526
-/

/-
Formalization of IRC Section 179 in Lean 4.

This module defines the data structures and functions necessary to calculate the Section 179 deduction
for a given taxpayer and set of properties. It includes:
- Type definitions for Currency, TaxYear, FilingStatus, PropertyType, Section179Property, and Taxpayer.
- Calculation functions for the dollar limitation, investment limitation reduction, SUV limitation,
  business income limitation, and carryover.
- Theorems proving key properties of the deduction, such as it never exceeding business income or the dollar limitation.
- Examples demonstrating the calculations for various scenarios.

References:
- IRC §179(a): Treatment as expenses
- IRC §179(b)(1): Dollar limitation
- IRC §179(b)(2): Reduction in limitation
- IRC §179(b)(3): Limitation based on income
- IRC §179(b)(4): Married individuals filing separately
- IRC §179(b)(5): Limitation on cost taken into account for certain passenger vehicles
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for IRC Section 179 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions (inline these if needed)
def Currency := Int
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Defining instances for Currency and TaxYear, and defining PropertyType, Section179Property, Taxpayer, and constants.
-/
instance : Repr TaxYear where
  reprPrec t _ := "TaxYear.mk " ++ repr t.year

instance : Repr Currency := inferInstanceAs (Repr Int)
instance {n} : OfNat Currency n := inferInstanceAs (OfNat Int n)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)

inductive PropertyType
  | General
  | SportUtilityVehicle
  deriving DecidableEq, Repr

structure Section179Property where
  cost : Currency
  type : PropertyType
  placedInServiceYear : TaxYear
  deriving DecidableEq, Repr

structure Taxpayer where
  filingStatus : FilingStatus
  businessIncome : Currency
  properties : List Section179Property
  carryover : Currency
  deriving DecidableEq, Repr

-- IRC §179(b)(1) Dollar limitation
def max_deduction_limit : Currency := 2500000

-- IRC §179(b)(2) Reduction in limitation threshold
def investment_limit : Currency := 4000000

-- IRC §179(b)(5) Limitation on cost taken into account for certain passenger vehicles
def suv_limit : Currency := 25000

/-
Adding Min/Max instances for Currency and implementing calculation functions for IRC Section 179.
-/
instance : Min Currency := inferInstanceAs (Min Int)
instance : Max Currency := inferInstanceAs (Max Int)

def get_property_cost (p : Section179Property) : Currency := p.cost

def is_suv (p : Section179Property) : Bool :=
  match p.type with
  | .SportUtilityVehicle => true
  | _ => false

-- IRC §179(b)(5)(A)
def suv_limited_cost (p : Section179Property) : Currency :=
  if is_suv p then min p.cost suv_limit else p.cost

def total_cost_placed_in_service (t : Taxpayer) : Currency :=
  t.properties.foldl (fun acc p => acc + p.cost) 0

def total_eligible_cost (t : Taxpayer) : Currency :=
  t.properties.foldl (fun acc p => acc + suv_limited_cost p) 0

-- IRC §179(b)(2) Reduction in limitation
def limitation_reduction (placed_in_service : Currency) : Currency :=
  if placed_in_service > investment_limit then
    placed_in_service - investment_limit
  else
    0

-- IRC §179(b)(1) & (b)(2) Dollar limitation with reduction
def calculated_dollar_limitation (placed_in_service : Currency) : Currency :=
  let reduction := limitation_reduction placed_in_service
  let limit := max_deduction_limit - reduction
  if limit < 0 then 0 else limit

-- IRC §179(b)(4) Married individuals filing separately
def apply_mfs_limitation (limit : Currency) (status : FilingStatus) : Currency :=
  match status with
  | .MarriedFilingSeparately => limit / 2
  | _ => limit

-- IRC §179(a) & (b) Maximum deduction before income limitation
def max_deduction_before_income (t : Taxpayer) : Currency :=
  let placed_in_service := total_cost_placed_in_service t
  let base_limit := calculated_dollar_limitation placed_in_service
  let effective_limit := apply_mfs_limitation base_limit t.filingStatus
  let eligible := total_eligible_cost t
  min eligible effective_limit

-- IRC §179(b)(3) Limitation based on income
def allowable_deduction (t : Taxpayer) : Currency :=
  let max_ded := max_deduction_before_income t
  min max_ded t.businessIncome

-- IRC §179(b)(3)(B) Carryover
def calculate_carryover (t : Taxpayer) : Currency :=
  let max_ded := max_deduction_before_income t
  let allowed := allowable_deduction t
  let disallowed := max_ded - allowed
  t.carryover + disallowed

/-
Theorem: The allowable deduction is less than or equal to the business income.
-/
theorem allowable_deduction_le_business_income (t : Taxpayer) :
  allowable_deduction t ≤ t.businessIncome := by
  unfold allowable_deduction
  apply Int.min_le_right

/-
Adding LinearOrder instance for Currency and stating the theorem that allowable deduction is limited by the dollar limitation.
-/
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)

theorem allowable_deduction_le_dollar_limit (t : Taxpayer) :
  allowable_deduction t ≤ calculated_dollar_limitation (total_cost_placed_in_service t) := by
  -- Unfold the definitions of `allowable_deduction`, `max_deduction_before_income`, and `calculated_dollar_limitation`.
  unfold allowable_deduction max_deduction_before_income calculated_dollar_limitation;
  aesop;
  · unfold apply_mfs_limitation; aesop;
  · unfold apply_mfs_limitation; aesop;
    exact Or.inl <| Or.inr <| Int.ediv_le_self _ <| by assumption;

/-
Theorem: The cost of an SUV taken into account is less than or equal to the SUV limit.
-/
theorem suv_cost_le_limit (p : Section179Property) (h : p.type = PropertyType.SportUtilityVehicle) :
  suv_limited_cost p ≤ suv_limit := by
    unfold suv_limited_cost; aesop;
    cases p ; aesop;
    cases h_1

/-
Defining example taxpayers and properties, and proving theorems that assert the correctness of the calculations for these examples using native_decide.
-/
-- Examples and Tests

def year2023 : TaxYear := { year := 2023, h_valid := by
                              -- We can prove this by simple arithmetic.
                              norm_num }

-- Example 1: Simple case, well under all limits
def prop1 : Section179Property := {
  cost := 100000,
  type := .General,
  placedInServiceYear := year2023
}

def taxpayer1 : Taxpayer := {
  filingStatus := .Single,
  businessIncome := 500000,
  properties := [prop1],
  carryover := 0
}

theorem example1_correct : allowable_deduction taxpayer1 = 100000 := by
  unfold allowable_deduction;
  unfold max_deduction_before_income; unfold calculated_dollar_limitation; unfold limitation_reduction; unfold total_cost_placed_in_service; simp_all +decide ;

-- Example 2: SUV Limitation
def suv_prop : Section179Property := {
  cost := 60000,
  type := .SportUtilityVehicle,
  placedInServiceYear := year2023
}

def taxpayer_suv : Taxpayer := {
  filingStatus := .Single,
  businessIncome := 500000,
  properties := [suv_prop],
  carryover := 0
}

theorem example2_correct : allowable_deduction taxpayer_suv = 25000 := by
  unfold allowable_deduction;
  unfold max_deduction_before_income;
  unfold apply_mfs_limitation; unfold calculated_dollar_limitation; unfold total_cost_placed_in_service; unfold total_eligible_cost; simp +decide ;
  unfold suv_limited_cost; unfold max_deduction_limit; unfold limitation_reduction; simp +decide ;

-- Example 3: Investment Limitation Reduction
def large_prop : Section179Property := {
  cost := 4100000,
  type := .General,
  placedInServiceYear := year2023
}

def taxpayer_large : Taxpayer := {
  filingStatus := .Single,
  businessIncome := 5000000,
  properties := [large_prop],
  carryover := 0
}

theorem example3_limit_correct : calculated_dollar_limitation (total_cost_placed_in_service taxpayer_large) = 2400000 := by
  unfold calculated_dollar_limitation;
  unfold limitation_reduction total_cost_placed_in_service; norm_num;
  exact?

theorem example3_deduction_correct : allowable_deduction taxpayer_large = 2400000 := by
  simp +decide [ allowable_deduction, max_deduction_before_income, calculated_dollar_limitation, total_cost_placed_in_service, total_eligible_cost, suv_limited_cost ];
  unfold apply_mfs_limitation; simp +decide [ is_suv, max_deduction_limit, limitation_reduction, total_cost_placed_in_service, total_eligible_cost, suv_limited_cost ]

-- Example 4: Business Income Limitation
def taxpayer_low_income : Taxpayer := {
  filingStatus := .Single,
  businessIncome := 50000,
  properties := [prop1], -- Cost 100,000
  carryover := 0
}

theorem example4_deduction_correct : allowable_deduction taxpayer_low_income = 50000 := by
  unfold allowable_deduction;
  unfold max_deduction_before_income;
  unfold taxpayer_low_income; simp +decide ;
  unfold apply_mfs_limitation calculated_dollar_limitation total_cost_placed_in_service; simp +decide ;
  unfold prop1; unfold max_deduction_limit; unfold limitation_reduction; simp +decide ;

theorem example4_carryover_correct : calculate_carryover taxpayer_low_income = 50000 := by
  -- Applying the definitions of ` allowable_deduction` and `calculate_carryover` to `taxpayer_low_income`.
  simp (config := { decide := true }) only [calculate_carryover, allowable_deduction];
  unfold taxpayer_low_income;
  unfold max_deduction_before_income;
  unfold total_cost_placed_in_service total_eligible_cost;
  unfold prop1 suv_limited_cost apply_mfs_limitation calculated_dollar_limitation; simp +decide ;
  unfold limitation_reduction; simp +decide ;
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 91feabde-d0a7-47ab-b8aa-7e7537800dfc
-/

/-
Formalization of IRC Section 63 (Taxable Income Defined).
This module defines the calculation of taxable income, including the standard deduction,
itemized deductions, and adjustments for inflation and filing status.
It includes:
- Data structures for TaxYear, FilingStatus, TaxpayerInfo, and TaxableIncomeInput.
- Functions for calculating the standard deduction (basic and additional) and taxable income.
- Theorems proving properties such as non-negativity of the standard deduction and bounds on taxable income.
- Example evaluations for a single taxpayer in 2023.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for IRC Section 63 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Check for Rat.floor and Rat.ceil.
-/
#check Rat.floor
#check Rat.ceil
#check Int.floor

/-
Define TaxpayerInfo, instances for Currency, and helper functions for inflation and dependent limitation.
-/
-- Helper to unwrap Currency
def Currency.toInt (c : Currency) : Int := c

-- Instances for Currency
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance {n : Nat} : OfNat Currency n := inferInstanceAs (OfNat Int n)

structure TaxpayerInfo where
  filingStatus : FilingStatus
  isDependent : Bool
  earnedIncome : Currency
  isBlind : Bool
  isAged : Bool
  spouseItemizes : Bool
  isNonresidentAlien : Bool
  isShortPeriod : Bool
  isEntity : Bool
  deriving DecidableEq, Repr

def Rat.round (q : Rat) : Int :=
  (q + 1/2).floor

def inflationAdjustment (year : TaxYear) : Rat := 1

def applyInflation (amount : Currency) (year : TaxYear) : Currency :=
  let factor := inflationAdjustment year
  let amountRat : Rat := (amount.toInt : Rat)
  Rat.round (amountRat * factor)

def dependentLimitation (info : TaxpayerInfo) (year : TaxYear) : Currency :=
  let limitA := applyInflation 500 year
  let limitB := (applyInflation 250 year) + info.earnedIncome
  max limitA limitB

/-
Implement basicStandardDeduction, additionalStandardDeduction, and standardDeduction logic, handling filing status, inflation adjustments, dependent limitation, and ineligibility rules.
-/
-- (c)(3) & (f) Placeholder for additional standard deduction amount (Aged/Blind)
-- The text references subsection (f) which is not provided, but (4) implies it is inflation adjusted.
-- Using a historical base of $600 for illustration.
def baseAdditionalAmount : Currency := 600

def additionalAmount (year : TaxYear) : Currency :=
  applyInflation baseAdditionalAmount year

-- (c)(3) Additional standard deduction
def additionalStandardDeduction (info : TaxpayerInfo) (year : TaxYear) : Currency :=
  let amount := additionalAmount year
  let blindAmount := if info.isBlind then amount else 0
  let agedAmount := if info.isAged then amount else 0
  blindAmount + agedAmount

-- (c)(2) Basic standard deduction
def basicStandardDeduction (info : TaxpayerInfo) (year : TaxYear) : Currency :=
  -- (c)(7) Special rules for taxable years beginning after 2017
  let isPost2017 := year.year > 2017
  
  -- Base amounts
  let (amountB, amountC) := 
    if isPost2017 then
      (23625, 15750) -- Substituted amounts
    else
      (4400, 3000)   -- Original amounts

  -- (c)(2)(A) Joint return or surviving spouse: 200% of (C)
  -- (c)(2)(B) Head of household
  -- (c)(2)(C) Others
  let baseAmount := match info.filingStatus with
    | FilingStatus.MarriedFilingJointly => 2 * amountC
    | FilingStatus.QualifyingWidower => 2 * amountC
    | FilingStatus.HeadOfHousehold => amountB
    | _ => amountC

  -- Apply inflation?
  -- (c)(4) applies to (2)(B) and (2)(C).
  -- (c)(7)(B)(i) says (4) shall not apply to (2)(B) and (2)(C) for post-2017.
  let adjustedAmount := 
    if isPost2017 then
      baseAmount -- No inflation adjustment on the substituted amounts (per text provided)
    else
      applyInflation baseAmount year

  -- (c)(5) Limitation for dependents
  if info.isDependent then
    let limit := dependentLimitation info year
    min adjustedAmount limit
  else
    adjustedAmount

-- (c) Standard deduction
def standardDeduction (info : TaxpayerInfo) (year : TaxYear) : Currency :=
  -- (c)(6) Certain individuals not eligible
  if (info.filingStatus == FilingStatus.MarriedFilingSeparately && info.spouseItemizes) ||
     info.isNonresidentAlien ||
     info.isShortPeriod ||
     info.isEntity then
    0
  else
    let basic := basicStandardDeduction info year
    let additional := additionalStandardDeduction info year
    basic + additional

/-
Define TaxableIncomeInput structure and the taxableIncome function implementing IRC §63(a) and (b).
-/
structure TaxableIncomeInput where
  grossIncome : Currency
  adjustedGrossIncome : Currency
  itemizes : Bool
  allowedDeductions : Currency -- For itemizers (excluding standard deduction)
  additionalDeductions : Currency -- For non-itemizers (sum of (2)-(7))
  deriving DecidableEq, Repr

-- IRC §63(a) & (b) Taxable Income
def taxableIncome (info : TaxpayerInfo) (income : TaxableIncomeInput) (year : TaxYear) : Currency :=
  if income.itemizes then
    -- (a) In general (Itemizers): Gross income minus deductions allowed by this chapter (other than standard deduction)
    income.grossIncome - income.allowedDeductions
  else
    -- (b) Individuals who do not itemize: AGI minus standard deduction and other specified deductions
    let stdDed := standardDeduction info year
    income.adjustedGrossIncome - stdDed - income.additionalDeductions

/-
Check if the environment is responsive.
-/
#check 1

/-
Theorem: The standard deduction is always non-negative.
-/
theorem standardDeduction_nonneg (info : TaxpayerInfo) (year : TaxYear) :
  standardDeduction info year ≥ 0 := by
    unfold standardDeduction;
    -- Since both the basic and additional amounts are calculated using `applyInflation`, which ensures non-negative results, their sum is also non-negative.
    have h_nonneg : 0 ≤ basicStandardDeduction info year ∧ 0 ≤ additionalStandardDeduction info year := by
      constructor;
      · unfold basicStandardDeduction;
        unfold dependentLimitation; aesop;
        any_goals norm_num [ applyInflation, inflationAdjustment ];
        any_goals native_decide;
        all_goals exact Or.inl ( by native_decide ) ;
      · unfold additionalStandardDeduction;
        unfold additionalAmount;
        unfold applyInflation;
        unfold inflationAdjustment; norm_num;
        split_ifs;
        · native_decide +revert;
        · native_decide;
        · native_decide +revert;
        · decide +revert;
    aesop;
    exact Int.add_nonneg left right

/-
Theorem: The standard deduction is zero for ineligible individuals (nonresident aliens, short periods, entities, or married filing separately where spouse itemizes).
-/
theorem standardDeduction_zero_for_ineligible (info : TaxpayerInfo) (year : TaxYear)
  (h : info.isNonresidentAlien ∨ info.isShortPeriod ∨ info.isEntity ∨ (info.filingStatus = FilingStatus.MarriedFilingSeparately ∧ info.spouseItemizes)) :
  standardDeduction info year = 0 := by
    -- By definition of `standardDeduction`, if any of the conditions in `h` are true, then `standardDeduction info year` will be zero.
    simp [standardDeduction, h];
    aesop

/-
Theorem: For an itemizer with non-negative allowed deductions, taxable income is less than or equal to gross income.
-/
theorem taxableIncome_itemizer_leq_gross (info : TaxpayerInfo) (income : TaxableIncomeInput) (year : TaxYear)
  (h_item : income.itemizes) (h_ded : income.allowedDeductions ≥ 0) :
  taxableIncome info income year ≤ income.grossIncome := by
    unfold taxableIncome; aesop;
    exact Int.sub_le_self _ h_ded

/-
Theorem: For a non-itemizer with non-negative additional deductions, taxable income is less than or equal to adjusted gross income.
-/
theorem taxableIncome_nonitemizer_leq_agi (info : TaxpayerInfo) (income : TaxableIncomeInput) (year : TaxYear)
  (h_item : ¬ income.itemizes) (h_add_ded : income.additionalDeductions ≥ 0) :
  taxableIncome info income year ≤ income.adjustedGrossIncome := by
    unfold taxableIncome;
    -- Since the standard deduction is non-negative, subtracting it from the adjusted gross income will result in a value that is less than or equal to the adjusted gross income.
    have h_std_ded_nonneg : 0 ≤ standardDeduction info year := by
      exact?;
    bound;
    · contradiction;
    · unfold Currency at * ; norm_num at * ; linarith

/-
Example evaluation for a single taxpayer in 2023.
-/
-- Example: Single taxpayer, 2023 tax year, standard deduction
def exampleYear : TaxYear := { year := 2023, h_valid := by norm_num }

def exampleTaxpayer : TaxpayerInfo := {
  filingStatus := FilingStatus.Single,
  isDependent := false,
  earnedIncome := 50000,
  isBlind := false,
  isAged := false,
  spouseItemizes := false,
  isNonresidentAlien := false,
  isShortPeriod := false,
  isEntity := false
}

def exampleIncome : TaxableIncomeInput := {
  grossIncome := 60000,
  adjustedGrossIncome := 60000,
  itemizes := false,
  allowedDeductions := 0,
  additionalDeductions := 0
}

#eval standardDeduction exampleTaxpayer exampleYear
#eval taxableIncome exampleTaxpayer exampleIncome exampleYear
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 15b91fa1-ed12-452e-a0bf-5bfc9ddb523c
-/

/-
Formalization of IRC Section 162 (Trade or Business Expenses).
This module defines the necessary types and structures to represent expenses, including salaries, travel, rent, and bribes.
It implements the logic for calculating deductible amounts based on the rules in §162(a), (b), and (c).
Key theorems verify that illegal bribes are not deductible, lavish travel expenses are limited, and salaries must be reasonable.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for IRC Section 162 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Instances for Currency and definitions of ExpenseType, Expense, and deductibleAmount.
-/
-- Instances for Currency to behave like Int
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : Mod Currency := inferInstanceAs (Mod Int)
instance (n : Nat) : OfNat Currency n := inferInstanceAs (OfNat Int n)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)

inductive ExpenseType
  | Salary (reasonableAmount : Currency) (servicesRendered : Bool)
  | Travel (awayFromHome : Bool) (lavishAmount : Currency) (employmentDurationDays : Nat) (isFederalCrimeInvestigation : Bool)
  | Rent (conditionForUse : Bool) (noEquity : Bool)
  | Bribe (illegal : Bool)
  | CharitableContribution (wouldBeAllowableUnder170 : Bool)
  | FineOrPenalty (governmentPaid : Bool) (amount : Currency)  -- IRC §162(f)
  | ExecutiveCompensation (isPublicCompany : Bool) (isCoveredEmployee : Bool) (amount : Currency)  -- IRC §162(m)
  | LobbyingExpense (isDirectLobbying : Bool) (amount : Currency)  -- IRC §162(e)
  | Other
  deriving DecidableEq, Repr

structure Expense where
  amount : Currency
  type : ExpenseType
  ordinary : Bool
  necessary : Bool
  paidOrIncurred : Bool
  tradeOrBusiness : Bool
  deriving DecidableEq, Repr

def deductibleAmount (e : Expense) : Currency :=
  if ¬(e.ordinary ∧ e.necessary ∧ e.paidOrIncurred ∧ e.tradeOrBusiness) then
    0
  else
    match e.type with
    | ExpenseType.Salary reasonableAmount servicesRendered =>
      if servicesRendered then min e.amount reasonableAmount else 0
    | ExpenseType.Travel awayFromHome lavishAmount employmentDurationDays isFederalCrimeInvestigation =>
      let isTemporarilyAway := if isFederalCrimeInvestigation then true else employmentDurationDays ≤ 365
      if awayFromHome ∧ isTemporarilyAway then
        max 0 (e.amount - lavishAmount)
      else
        0
    | ExpenseType.Rent conditionForUse noEquity =>
      if conditionForUse ∧ noEquity then e.amount else 0
    | ExpenseType.Bribe illegal =>
      if illegal then 0 else e.amount
    | ExpenseType.CharitableContribution wouldBeAllowableUnder170 =>
      if wouldBeAllowableUnder170 then 0 else e.amount
    | ExpenseType.FineOrPenalty govt amt =>
      if govt then 0 else amt  -- §162(f): Government fines NOT deductible
    | ExpenseType.ExecutiveCompensation isPub isCovered amt =>
      if isPub && isCovered then min amt 1000000 else amt  -- §162(m): $1M cap for public companies
    | ExpenseType.LobbyingExpense _ amt =>
      0  -- §162(e): NO deduction for lobbying
    | ExpenseType.Other => e.amount

/-
Theorem verifying that illegal bribes are not deductible.
-/
-- IRC §162(c)(1): Illegal bribes are not deductible
theorem illegal_bribe_not_deductible (e : Expense) (h_illegal : Bool) :
  e.type = ExpenseType.Bribe h_illegal → h_illegal = true → deductibleAmount e = 0 := by
  unfold deductibleAmount; aesop;

/-
Theorem verifying that lavish travel expenses are limited to the amount exceeding the lavish portion, provided other conditions are met.
-/
-- IRC §162(a)(2): Lavish travel expenses are limited
theorem lavish_travel_limited (e : Expense) (away : Bool) (lavish : Currency) (days : Nat) (fed : Bool) :
  e.type = ExpenseType.Travel away lavish days fed →
  e.ordinary ∧ e.necessary ∧ e.paidOrIncurred ∧ e.tradeOrBusiness →
  away = true →
  (if fed then true else days ≤ 365) →
  deductibleAmount e = max 0 (e.amount - lavish) := by
  unfold deductibleAmount ; aesop

/-
Theorem verifying that salary deductions are limited to a reasonable amount for services actually rendered.
-/
-- IRC §162(a)(1): Salaries are limited to reasonable amount
theorem salary_reasonable_limit (e : Expense) (reasonable : Currency) (rendered : Bool) :
  e.type = ExpenseType.Salary reasonable rendered →
  e.ordinary ∧ e.necessary ∧ e.paidOrIncurred ∧ e.tradeOrBusiness →
  rendered = true →
  deductibleAmount e = min e.amount reasonable := by
  unfold deductibleAmount;
  aesop

/-
Theorem verifying that expenses must be both ordinary and necessary to be deductible.
-/
-- General rule: Expenses must be ordinary and necessary
theorem not_ordinary_or_necessary_not_deductible (e : Expense) :
  ¬(e.ordinary ∧ e.necessary) → deductibleAmount e = 0 := by
  simp [deductibleAmount, *];
  aesop

/-
Examples and theorems for newly added provisions (§162(f), §162(m), §162(e)).
-/

-- Example 1: Government fine (NOT deductible)
def example_govt_fine : Expense := {
  amount := 50000
  type := ExpenseType.FineOrPenalty true 50000
  ordinary := true
  necessary := true
  paidOrIncurred := true
  tradeOrBusiness := true
}

theorem govt_fine_not_deductible : deductibleAmount example_govt_fine = 0 := by
  unfold deductibleAmount example_govt_fine; rfl

-- Example 2: Private penalty (deductible)
def example_private_penalty : Expense := {
  amount := 10000
  type := ExpenseType.FineOrPenalty false 10000
  ordinary := true
  necessary := true
  paidOrIncurred := true
  tradeOrBusiness := true
}

theorem private_penalty_deductible : deductibleAmount example_private_penalty = 10000 := by
  unfold deductibleAmount example_private_penalty; rfl

-- Example 3: Executive compensation over $1M cap (public company, covered employee)
def example_exec_comp_capped : Expense := {
  amount := 2000000
  type := ExpenseType.ExecutiveCompensation true true 2000000
  ordinary := true
  necessary := true
  paidOrIncurred := true
  tradeOrBusiness := true
}

theorem exec_comp_capped_at_1m : deductibleAmount example_exec_comp_capped = 1000000 := by
  unfold deductibleAmount example_exec_comp_capped; rfl

-- Example 4: Lobbying expense (NOT deductible)
def example_lobbying : Expense := {
  amount := 75000
  type := ExpenseType.LobbyingExpense true 75000
  ordinary := true
  necessary := true
  paidOrIncurred := true
  tradeOrBusiness := true
}

theorem lobbying_not_deductible : deductibleAmount example_lobbying = 0 := by
  unfold deductibleAmount example_lobbying; rfl
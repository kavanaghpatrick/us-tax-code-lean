/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9efda9df-596f-429d-937a-e6e020102750
-/

/-
Formalization of IRC Section 469 (Passive Activity Losses and Credits Limited).
This module defines the necessary types (Taxpayer, Activity, ActivityContext) and implements the logic for determining passive activities and calculating disallowed losses and credits.
It covers:
- §469(a): Disallowance of passive activity losses and credits.
- §469(b): Carryover of disallowed losses.
- §469(c): Definition of passive activity, including exceptions for working interests in oil and gas and rental real estate for real property businesses.
Theorems are provided to verify the correctness of the loss calculations and the application of exceptions.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for IRC Section 469 formalization including Currency, TaxYear, and FilingStatus.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Definitions for ActivityType, Activity, and Taxpayer to support IRC §469 logic, with Repr instance for Currency.
-/
instance : Repr Currency := inferInstanceAs (Repr Int)

inductive ActivityType
  | TradeOrBusiness
  | Rental
  | OilAndGasWorkingInterest
  | Other
  deriving DecidableEq, Repr

structure Activity where
  id : String
  type : ActivityType
  netIncome : Currency -- Positive for income, negative for loss
  credits : Currency   -- Credits are generally positive amounts reducing tax
  deriving DecidableEq, Repr

structure Taxpayer where
  id : String
  filingStatus : FilingStatus
  isCloselyHeldCCorp : Bool
  isPersonalServiceCorp : Bool
  deriving DecidableEq, Repr

/-
Corrected definition of `isPassiveActivity` handling the logic for Oil & Gas, Rental, and Trade/Business activities properly.
-/
structure ActivityContext where
  materiallyParticipates : Bool
  isRealPropertyBusiness : Bool
  isRentalRealEstate : Bool
  holdsInterestThroughLimitedLiabilityEntity : Bool
  deriving DecidableEq, Repr

/--
Determines if an activity is a "passive activity" under IRC §469(c).
-/
def isPassiveActivity (t : Taxpayer) (a : Activity) (ctx : ActivityContext) : Bool :=
  match a.type with
  | ActivityType.OilAndGasWorkingInterest =>
    -- IRC §469(c)(3): Not passive if liability is not limited
    if !ctx.holdsInterestThroughLimitedLiabilityEntity then false
    else
      -- If liability IS limited, the exception (c)(3) does not apply.
      -- Fall back to general rule (c)(1): Passive if not materially participating.
      !ctx.materiallyParticipates
  | ActivityType.Rental =>
    -- IRC §469(c)(2): Rental is passive.
    -- IRC §469(c)(7): Exception for real property business.
    if ctx.isRealPropertyBusiness && ctx.isRentalRealEstate then
      !ctx.materiallyParticipates
    else
      true
  | ActivityType.TradeOrBusiness =>
    -- IRC §469(c)(1): Passive if not materially participating.
    !ctx.materiallyParticipates
  | ActivityType.Other =>
    -- Portfolio income, etc. generally not passive.
    false

/-
Adding necessary typeclass instances for Currency (Int) to support arithmetic and comparison operations.
-/
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Neg Currency := inferInstanceAs (Neg Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : DecidableRel (· < · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· < · : Int → Int → Prop))
instance : DecidableRel (· ≤ · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· ≤ · : Int → Int → Prop))
instance {n : Nat} : OfNat Currency n := inferInstanceAs (OfNat Int n)

/-
Calculation functions for Passive Activity Loss and Credit according to IRC §469(a) and (d), now with proper typeclass instances.
-/
/--
Calculates the Net Passive Income (or Loss if negative) for the taxable year.
Returns the raw net amount (positive for income, negative for loss).
-/
def calculateNetPassiveIncome (t : Taxpayer) (activities : List (Activity × ActivityContext)) : Currency :=
  let passiveActivities := activities.filter (fun (a, ctx) => isPassiveActivity t a ctx)
  passiveActivities.foldl (fun sum (a, _) => sum + a.netIncome) 0

/--
IRC §469(a)(1)(A): The passive activity loss.
Defined as the amount by which the aggregate losses from all passive activities for the taxable year exceed the aggregate income from all passive activities for such year.
This is equivalent to the absolute value of `calculateNetPassiveIncome` if it is negative, else 0.
-/
def calculatePassiveActivityLoss (t : Taxpayer) (activities : List (Activity × ActivityContext)) : Currency :=
  let netIncome := calculateNetPassiveIncome t activities
  if netIncome < 0 then -netIncome else 0

/--
IRC §469(a)(1)(B): The passive activity credit.
The amount by which the sum of the credits from all passive activities allowable for the taxable year exceeds the regular tax liability of the taxpayer for the taxable year allocable to all passive activities.
Note: We assume `taxLiabilityAllocableToPassive` is provided as an input since it requires complex tax calculation.
-/
def calculatePassiveActivityCredit (t : Taxpayer) (activities : List (Activity × ActivityContext)) (taxLiabilityAllocableToPassive : Currency) : Currency :=
  let passiveActivities := activities.filter (fun (a, ctx) => isPassiveActivity t a ctx)
  let totalCredits := passiveActivities.foldl (fun sum (a, _) => sum + a.credits) 0
  if totalCredits > taxLiabilityAllocableToPassive then totalCredits - taxLiabilityAllocableToPassive else 0

/--
IRC §469(a): Disallowance of Passive Activity Loss and Credit.
Returns the disallowed loss and disallowed credit.
-/
structure DisallowedAmounts where
  loss : Currency
  credit : Currency
  deriving DecidableEq, Repr

def calculateDisallowedAmounts (t : Taxpayer) (activities : List (Activity × ActivityContext)) (taxLiabilityAllocableToPassive : Currency) : DisallowedAmounts :=
  { loss := calculatePassiveActivityLoss t activities,
    credit := calculatePassiveActivityCredit t activities taxLiabilityAllocableToPassive }

/-
Theorem: The calculated passive activity loss is always non-negative.
-/
theorem passive_loss_nonneg (t : Taxpayer) (activities : List (Activity × ActivityContext)) :
  calculatePassiveActivityLoss t activities ≥ 0 := by
    -- The net income from passive activities is either non-negative or negative, and the calculatePassiveActivityLoss function returns either 0 or the absolute value of the negative income.
    apply Int.le_of_lt_add_one;
    unfold calculatePassiveActivityLoss; aesop;
    exact h.trans_le ( by norm_num )

/-
Theorem: The calculated passive activity credit is always non-negative.
-/
theorem passive_credit_nonneg (t : Taxpayer) (activities : List (Activity × ActivityContext)) (taxLiability : Currency) :
  calculatePassiveActivityCredit t activities taxLiability ≥ 0 := by
    unfold calculatePassiveActivityCredit;
    aesop;
    · exact Int.sub_nonneg_of_le h.le;
    · native_decide +revert

/-
Theorem: If the net passive income is non-negative, the passive activity loss is zero.
-/
theorem loss_is_zero_if_income_nonneg (t : Taxpayer) (activities : List (Activity × ActivityContext)) :
  calculateNetPassiveIncome t activities ≥ 0 → calculatePassiveActivityLoss t activities = 0 := by
    cases h : calculateNetPassiveIncome t activities <;> aesop;
    · -- By definition of `calculatePassiveActivityLoss`, if the net passive income is non-negative, then the passive activity loss is zero.
      simp [calculatePassiveActivityLoss, h];
      exact fun h => False.elim <| h.not_le a_1;
    · contradiction

/-
Theorem: If the net passive income is negative, the passive activity loss is the magnitude (negation) of the net income.
-/
theorem loss_is_magnitude_if_income_neg (t : Taxpayer) (activities : List (Activity × ActivityContext)) :
  calculateNetPassiveIncome t activities < 0 → calculatePassiveActivityLoss t activities = -calculateNetPassiveIncome t activities := by
    unfold calculatePassiveActivityLoss; aesop;

/-
Theorem: A rental real estate activity is NOT passive if the taxpayer is in a real property business and materially participates (IRC §469(c)(7)).
-/
theorem rental_real_estate_active_if_material_participation
  (t : Taxpayer) (a : Activity) (ctx : ActivityContext)
  (h_type : a.type = ActivityType.Rental)
  (h_rpb : ctx.isRealPropertyBusiness = true)
  (h_rre : ctx.isRentalRealEstate = true)
  (h_mp : ctx.materiallyParticipates = true) :
  isPassiveActivity t a ctx = false := by
    unfold isPassiveActivity; aesop

/-
Theorem: A rental activity is passive if the taxpayer is NOT in a real property business, even if they materially participate (IRC §469(c)(2) and (c)(4)).
-/
theorem rental_passive_if_not_rpb
  (t : Taxpayer) (a : Activity) (ctx : ActivityContext)
  (h_type : a.type = ActivityType.Rental)
  (h_not_rpb : ctx.isRealPropertyBusiness = false)
  (h_mp : ctx.materiallyParticipates = true) :
  isPassiveActivity t a ctx = true := by
    unfold isPassiveActivity; aesop;

/-
Function and theorem for applying carryover losses from previous years as deductions in the current year (IRC §469(b)).
-/
/--
IRC §469(b): Disallowed loss or credit carried to next year.
"Except as otherwise provided in this section, any loss or credit from an activity which is disallowed under subsection (a) shall be treated as a deduction or credit allocable to such activity in the next taxable year."
This function updates an activity's net income by applying the disallowed loss from the previous year as a deduction.
Assumes `priorDisallowedLoss` is a non-negative amount representing the loss.
-/
def applyCarryoverLoss (a : Activity) (priorDisallowedLoss : Currency) : Activity :=
  { a with netIncome := a.netIncome - priorDisallowedLoss }

theorem carryover_reduces_income (a : Activity) (loss : Currency) (h_loss : loss ≥ 0) :
  (applyCarryoverLoss a loss).netIncome ≤ a.netIncome := by
    unfold applyCarryoverLoss
    simp
    exact Int.sub_le_self a.netIncome h_loss
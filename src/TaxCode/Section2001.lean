/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 0a8f5548-6ce3-4d8a-90f2-bba325118f0d
-/

/-
Formalization of IRC Section 2001 (Imposition and rate of tax).
This module defines the data structures and functions necessary to compute the estate tax
according to the provisions of IRC §2001(a), (b), and (c).
It includes:
- `Currency` type alias for integer arithmetic.
- `TaxYear` and `FilingStatus` structures.
- `section2001_c_rate_schedule`: The progressive rate schedule from §2001(c).
- `section2001_b_computation`: The main tax computation logic from §2001(b).
- Theorems proving the monotonicity of the rate schedule and non-negativity of the tax.
- An example calculation matching the provided scenario.
- TODOs for subsections (d), (e), and (f).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for Currency, TaxYear, and FilingStatus as requested.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Instances for Currency and implementation of the rate schedule from IRC §2001(c).
-/
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableRel ((· ≤ ·) : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· ≤ · : Int → Int → Prop))
instance (n : Nat) [OfNat Int n] : OfNat Currency n := inferInstanceAs (OfNat Int n)

def section2001_c_rate_schedule (amount : Currency) : Currency :=
  if amount ≤ 10000 then
    (amount * 18) / 100
  else if amount ≤ 20000 then
    1800 + ((amount - 10000) * 20) / 100
  else if amount ≤ 40000 then
    3800 + ((amount - 20000) * 22) / 100
  else if amount ≤ 60000 then
    8200 + ((amount - 40000) * 24) / 100
  else if amount ≤ 80000 then
    13000 + ((amount - 60000) * 26) / 100
  else if amount ≤ 100000 then
    18200 + ((amount - 80000) * 28) / 100
  else if amount ≤ 150000 then
    23800 + ((amount - 100000) * 30) / 100
  else if amount ≤ 250000 then
    38800 + ((amount - 150000) * 32) / 100
  else if amount ≤ 500000 then
    70800 + ((amount - 250000) * 34) / 100
  else if amount ≤ 750000 then
    155800 + ((amount - 500000) * 37) / 100
  else if amount ≤ 1000000 then
    248300 + ((amount - 750000) * 39) / 100
  else
    345800 + ((amount - 1000000) * 40) / 100

/-
Added missing instances for Currency and implemented the input structure and tax computation for IRC §2001(b).
-/
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)

structure Section2001Input where
  taxable_estate : Currency
  adjusted_taxable_gifts : Currency
  aggregate_gift_tax_payable : Currency
  deriving DecidableEq, Repr

def section2001_b_computation (input : Section2001Input) : Currency :=
  let tentative_tax_base := input.taxable_estate + input.adjusted_taxable_gifts
  let tentative_tax := section2001_c_rate_schedule tentative_tax_base
  max 0 (tentative_tax - input.aggregate_gift_tax_payable)

/-
Helper lemma: Affine transformation with non-negative slope and positive divisor is monotonic on integers.
-/
lemma int_affine_mono {x y m d c : Int} (h : x ≤ y) (hm : 0 ≤ m) (hd : 0 < d) :
  c + x * m / d ≤ c + y * m / d := by
  nlinarith [ Int.mul_ediv_add_emod ( x * m ) d, Int.mul_ediv_add_emod ( y * m ) d, Int.emod_nonneg ( x * m ) hd.ne', Int.emod_lt_of_pos ( x * m ) hd, Int.emod_nonneg ( y * m ) hd.ne', Int.emod_lt_of_pos ( y * m ) hd ]

/-
Helper lemma: Gluing two monotonic functions on integers preserves monotonicity if the boundary condition holds.
-/
lemma int_mono_glue {f g : Int → Int} {c : Int}
    (hf : ∀ x y, x ≤ y → y ≤ c → f x ≤ f y)
    (hg : ∀ x y, c < x → x ≤ y → g x ≤ g y)
    (h_glue : f c ≤ g (c + 1)) :
    ∀ x y, x ≤ y → (if x ≤ c then f x else g x) ≤ (if y ≤ c then f y else g y) := by
      aesop;
      · grind;
      · linarith

/-
Helper lemma: General affine transformation with non-negative slope and positive divisor is monotonic on integers.
-/
lemma int_affine_mono_general {x y m d k c : Int} (h : x ≤ y) (hm : 0 ≤ m) (hd : 0 < d) :
  c + (x * m + k) / d ≤ c + (y * m + k) / d := by
    exact add_le_add_left ( Int.ediv_le_ediv ( by positivity ) ( by nlinarith ) ) _

/-
Theorem stating that the rate schedule in IRC §2001(c) is monotonic (non-decreasing).
-/
theorem section2001_c_rate_schedule_monotone (a b : Currency) (h : a ≤ b) :
  section2001_c_rate_schedule a ≤ section2001_c_rate_schedule b := by
    apply_rules [ int_mono_glue ];
    · exact fun x y hxy hy => Int.ediv_le_ediv ( by norm_num ) ( by linarith );
    · intro x y hx hy;
      apply_rules [ int_mono_glue ];
      · exact fun x y hxy hy => by linarith [ Int.mul_ediv_add_emod ( ( x - 10000 ) * 20 ) 100, Int.mul_ediv_add_emod ( ( y - 10000 ) * 20 ) 100, Int.emod_nonneg ( ( x - 10000 ) * 20 ) ( by norm_num : ( 100 : ℤ ) ≠ 0 ), Int.emod_lt_of_pos ( ( x - 10000 ) * 20 ) ( by norm_num : ( 100 : ℤ ) > 0 ), Int.emod_nonneg ( ( y - 10000 ) * 20 ) ( by norm_num : ( 100 : ℤ ) ≠ 0 ), Int.emod_lt_of_pos ( ( y - 10000 ) * 20 ) ( by norm_num : ( 100 : ℤ ) > 0 ) ] ;
      · intros x y hx hy; apply int_mono_glue;
        · exact fun x y hxy hy => add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
        · intros x y hx hy; apply int_mono_glue;
          · exact fun x y hxy hy => add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
          · intros x y hx hy; apply int_mono_glue;
            · intros x y hxy hy; exact add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
            · intros x y hx hy; apply int_mono_glue;
              · exact fun x y hxy hy => by linarith [ Int.ediv_le_ediv ( by norm_num : ( 0 : ℤ ) < 100 ) ( by linarith : ( x - 80000 ) * 28 ≤ ( y - 80000 ) * 28 ) ] ;
              · intros x y hx hy; apply int_mono_glue;
                · bound;
                  exact Int.ediv_le_ediv ( by norm_num ) ( by linarith );
                · intros x y hx hy; apply int_mono_glue;
                  · exact fun x y hxy hy => add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
                  · intros x y hx hy; apply int_mono_glue;
                    · bound;
                      exact Int.ediv_le_ediv ( by norm_num ) ( by linarith );
                    · intros x y hx hy; apply int_mono_glue;
                      · exact fun x y hxy hy => by linarith [ Int.mul_ediv_add_emod ( ( x - 500000 ) * 37 ) 100, Int.mul_ediv_add_emod ( ( y - 500000 ) * 37 ) 100, Int.emod_nonneg ( ( x - 500000 ) * 37 ) ( by norm_num : ( 100 : ℤ ) ≠ 0 ), Int.emod_lt_of_pos ( ( x - 500000 ) * 37 ) ( by norm_num : ( 0 : ℤ ) < 100 ), Int.emod_nonneg ( ( y - 500000 ) * 37 ) ( by norm_num : ( 100 : ℤ ) ≠ 0 ), Int.emod_lt_of_pos ( ( y - 500000 ) * 37 ) ( by norm_num : ( 0 : ℤ ) < 100 ) ] ;
                      · intros x y hx hy; apply int_mono_glue;
                        · exact fun x y hxy hy => add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
                        · exact fun x y hx hy => add_le_add_left ( Int.ediv_le_ediv ( by norm_num ) ( by linarith ) ) _;
                        · native_decide +revert;
                        · exact?;
                      · native_decide +revert;
                      · linarith;
                    · native_decide +revert;
                    · linarith;
                  · native_decide +revert;
                  · linarith;
                · native_decide +revert;
                · linarith;
              · native_decide +revert;
              · linarith;
            · decide +revert;
            · linarith;
          · bound;
          · exact?;
        · decide +kernel;
        · bound;
      · exact?;
    · decide +revert

/-
Helper lemma: Specific affine transformation monotonicity for the rate schedule formula.
-/
lemma int_affine_mono_specific {x y A B C D : Int} (h : x ≤ y) (hC : 0 ≤ C) (hD : 0 < D) :
  A + (x - B) * C / D ≤ A + (y - B) * C / D := by
    norm_num +zetaDelta at *;
    exact Int.ediv_le_ediv ( by positivity ) ( by nlinarith )

/-
Theorem stating that the tax computed under IRC §2001(b) is always non-negative.
-/
theorem section2001_b_computation_nonneg (input : Section2001Input) :
  0 ≤ section2001_b_computation input := by
  unfold section2001_b_computation
  exact le_max_left 0 _

/-
Example calculation and TODOs for complex subsections.
-/
-- Example calculation
-- Taxable estate: $1,000,000
-- Adjusted taxable gifts: $0
-- Aggregate gift tax payable: $0
-- Expected Tax: $345,800

def example_input : Section2001Input := {
  taxable_estate := 1000000
  adjusted_taxable_gifts := 0
  aggregate_gift_tax_payable := 0
}

#eval section2001_b_computation example_input

-- TODO: Implement adjustments for gift tax paid by spouse (IRC §2001(d))
-- TODO: Implement coordination of sections 2513 and 2035 (IRC §2001(e))
-- TODO: Implement valuation of gifts logic (IRC §2001(f))
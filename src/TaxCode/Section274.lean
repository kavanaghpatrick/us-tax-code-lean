/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7aa2ae4e-c798-4ec1-9138-a8e3a8a2852a
-/

/-
Formalization of IRC Section 274 regarding the disallowance of certain entertainment, gift, and travel expenses.

This module defines the necessary data structures to represent expenses, including specific details for gifts and foreign travel. It implements the logic for calculating the deductible amount of an expense based on the rules set forth in IRC §274(a), (b), (c), and (d).

Key features:
- `Currency` is defined as `Int` to avoid floating-point inaccuracies.
- `ExpenseCategory` distinguishes between different types of expenses (Entertainment, Gifts, Foreign Travel, etc.).
- `calculateDeductibleAmount` implements the core logic:
  - Disallows entertainment expenses (§274(a)(1)).
  - Disallows club dues (§274(a)(3)).
  - Disallows qualified transportation fringes (§274(a)(4)).
  - Applies the $25 limitation to gifts, with exceptions for small imprinted items and signage (§274(b)).
  - Allocates foreign travel expenses based on business vs. total time, with exceptions for short trips or low personal time (§274(c)).
  - Requires substantiation (§274(d)).

Theorems are provided to verify that the implementation adheres to these legal requirements.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

instance : Repr TaxYear where
  reprPrec t _ := "TaxYear.mk " ++ repr t.year

instance : Repr Currency := inferInstanceAs (Repr Int)

structure GiftDetails where
  recipient : String
  imprinted_and_distributed : Bool -- §274(b)(1)(A)
  is_signage : Bool -- §274(b)(1)(B)
  deriving DecidableEq, Repr

structure ForeignTravelDetails where
  days_total : Nat
  days_business : Nat
  deriving DecidableEq, Repr

inductive ExpenseCategory
  | EntertainmentActivity -- §274(a)(1)(A)
  | EntertainmentFacility -- §274(a)(1)(B)
  | ClubDues -- §274(a)(3)
  | QualifiedTransportationFringe -- §274(a)(4)
  | Gift (details : GiftDetails) -- §274(b)
  | ForeignTravel (details : ForeignTravelDetails) -- §274(c)
  | Other
  deriving DecidableEq, Repr

structure Expense where
  amount : Currency
  category : ExpenseCategory
  substantiated : Bool -- §274(d)
  tax_year : TaxYear
  deriving DecidableEq, Repr

attribute [reducible] Currency

def isGiftSubjectToLimit (details : GiftDetails) (cost : Currency) : Bool :=
  -- §274(b)(1)(A): item cost <= $4, imprinted, distributed generally -> not a gift
  let exceptionA := cost <= 400 && details.imprinted_and_distributed
  -- §274(b)(1)(B): sign, display rack, etc. -> not a gift
  let exceptionB := details.is_signage
  !(exceptionA || exceptionB)

def calculateDeductibleAmount (e : Expense) (prior_gifts_amount : Currency) : Currency :=
  if !e.substantiated then 0 -- §274(d)
  else match e.category with
  | ExpenseCategory.EntertainmentActivity => 0 -- §274(a)(1)(A)
  | ExpenseCategory.EntertainmentFacility => 0 -- §274(a)(1)(B)
  | ExpenseCategory.ClubDues => 0 -- §274(a)(3)
  | ExpenseCategory.QualifiedTransportationFringe => 0 -- §274(a)(4)
  | ExpenseCategory.Gift details =>
    if isGiftSubjectToLimit details e.amount then
      let limit := 2500 -- $25.00
      let remaining := limit - prior_gifts_amount
      if remaining < 0 then 0
      else min e.amount remaining
    else
      e.amount -- Not considered a "gift" for §274(b) purposes, so fully deductible (assuming §162)
  | ExpenseCategory.ForeignTravel details =>
    -- §274(c)(2): Exception if travel <= 1 week OR < 25% personal time
    let one_week_days := 7
    let personal_days := details.days_total - details.days_business
    -- Note: We need to handle division carefully.
    -- "less than 25 percent of the total time" <=> personal * 4 < total
    if details.days_total <= one_week_days || personal_days * 4 < details.days_total then
      e.amount
    else
      -- §274(c)(1): Allocate based on business time
      if details.days_total == 0 then 0 else -- Avoid division by zero
      (e.amount * details.days_business) / details.days_total
  | ExpenseCategory.Other => e.amount

/-
Theorems verifying that entertainment and club dues are disallowed, and that gifts are subject to the $25 limit.
-/
theorem entertainment_disallowed (e : Expense) (prior : Currency) :
  (e.category = ExpenseCategory.EntertainmentActivity ∨ e.category = ExpenseCategory.EntertainmentFacility) →
  calculateDeductibleAmount e prior = 0 := by
  intro h
  unfold calculateDeductibleAmount
  split
  · rfl -- !substantiated
  · rename_i h_subst
    cases h with
    | inl h_act => rw [h_act]
    | inr h_fac => rw [h_fac]

theorem club_dues_disallowed (e : Expense) (prior : Currency) :
  e.category = ExpenseCategory.ClubDues →
  calculateDeductibleAmount e prior = 0 := by
  intro h
  unfold calculateDeductibleAmount
  split
  · rfl
  · rw [h]

theorem gift_limit_check (e : Expense) (prior : Currency) (details : GiftDetails) :
  e.category = ExpenseCategory.Gift details →
  isGiftSubjectToLimit details e.amount →
  prior ≥ 0 →
  calculateDeductibleAmount e prior + prior ≤ 2500 ∨ calculateDeductibleAmount e prior = 0 := by
  intro h_cat h_limit h_prior_nonneg
  unfold calculateDeductibleAmount
  split
  · right; rfl -- unsubstantiated
  · rw [h_cat]
    simp only [h_limit, ite_true]
    -- Logic: if remaining < 0 then 0 else min amount remaining
    split
    · right; rfl
    · left
      -- min e.amount (2500 - prior) + prior <= 2500
      -- min (e.amount + prior) 2500 <= 2500
      -- which is true
      cases min_cases e.amount ( 2500 - prior ) <;> linarith

theorem foreign_travel_allocation (e : Expense) (details : ForeignTravelDetails) (prior : Currency) :
  e.category = ExpenseCategory.ForeignTravel details →
  e.substantiated →
  details.days_total > 7 →
  (details.days_total - details.days_business) * 4 ≥ details.days_total →
  details.days_total > 0 →
  calculateDeductibleAmount e prior = (e.amount * details.days_business) / details.days_total := by
  intro h_cat h_subst h_days h_personal h_total_pos
  unfold calculateDeductibleAmount
  rw [h_cat]
  simp only [h_subst, not_true, if_false] -- substantiated is true, so !substantiated is false
  -- Now we are in the ForeignTravel branch
  -- The condition is: details.days_total <= 7 || personal_days * 4 < details.days_total
  -- We know details.days_total > 7, so the first part is false.
  -- We know personal_days * 4 >= details.days_total, so the second part is false.
  have h_cond1 : ¬ (details.days_total <= 7) := by
    linarith
  have h_cond2 : ¬ ((details.days_total - details.days_business) * 4 < details.days_total) := by
    linarith
  simp [h_cond1, h_cond2]
  -- The else branch:
  -- if details.days_total == 0 then 0 else (e.amount * details.days_business) / details.days_total
  -- We know details.days_total > 0, so it's not 0.
  have h_nonzero : details.days_total ≠ 0 := by
    linarith
  simp [h_nonzero]

theorem qualified_transportation_fringes_disallowed (e : Expense) (prior : Currency) :
  e.category = ExpenseCategory.QualifiedTransportationFringe →
  calculateDeductibleAmount e prior = 0 := by
  intro h
  unfold calculateDeductibleAmount
  split
  · rfl
  · rw [h]
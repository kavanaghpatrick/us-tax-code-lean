/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ef5b431c-e790-46b5-b7cb-1e4db1493065
-/

/-
Formalization of IRC Section 121: Exclusion of gain from sale of principal residence.

This module defines the data structures and functions necessary to calculate the exclusion of gain from the sale of a principal residence under IRC §121. It includes:
- Type definitions for `Currency`, `TaxYear`, `FilingStatus`, and time periods.
- Logic for ownership and use tests (2 out of 5 years).
- Logic for the frequency limit (once every 2 years).
- Calculation of the exclusion limit ($250,000 or $500,000) based on filing status and joint return requirements.
- Implementation of the nonqualified use ratio calculation for the 2009 exception.
- Theorems verifying that the calculated exclusion does not exceed the statutory limit or the total gain.

The formalization handles the main provisions of §121(a), (b)(1)-(4), and (b)(5). Subsection (c) regarding reduced exclusions for unforeseen circumstances is noted as a TODO.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

-- Date and Time representations
abbrev Day := Int

structure TimePeriod where
  start : Day
  finish : Day
  h_order : start ≤ finish
  deriving DecidableEq, Repr

def TimePeriod.length (i : TimePeriod) : Int := i.finish - i.start

def intersection (i1 i2 : TimePeriod) : Option TimePeriod :=
  let start := max i1.start i2.start
  let finish := min i1.finish i2.finish
  if h : start ≤ finish then
    some ⟨start, finish, h⟩
  else
    none

def intersectionLength (i1 i2 : TimePeriod) : Int :=
  match intersection i1 i2 with
  | some i => i.length
  | none => 0

def totalDaysInPeriods (periods : List TimePeriod) (period : TimePeriod) : Int :=
  (periods.map (fun i => intersectionLength i period)).sum

instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance (n : Nat) [OfNat Int n] : OfNat Currency n := ⟨(n : Int)⟩

def twoYearsInDays : Int := 730
def fiveYearsInDays : Int := 1825

def limitSingle : Currency := 250000
def limitJoint : Currency := 500000

structure PropertyHistory where
  ownershipPeriods : List TimePeriod
  usePeriods : List TimePeriod
  nonqualifiedUsePeriods : List TimePeriod
  deriving DecidableEq, Repr

structure Sale where
  date : Day
  gain : Currency
  propertyHistory : PropertyHistory
  deriving DecidableEq, Repr

def mkLookbackPeriod (endDate : Day) (days : Nat) : TimePeriod :=
  { start := endDate - days,
    finish := endDate,
    h_order := by
      have h : (days : Int) ≥ 0 := Int.ofNat_nonneg days
      show endDate - days ≤ endDate
      linarith }

def checkOwnership (history : PropertyHistory) (saleDate : Day) : Bool :=
  let period := mkLookbackPeriod saleDate 1825 -- 5 years
  totalDaysInPeriods history.ownershipPeriods period >= twoYearsInDays

def checkUse (history : PropertyHistory) (saleDate : Day) : Bool :=
  let period := mkLookbackPeriod saleDate 1825 -- 5 years
  totalDaysInPeriods history.usePeriods period >= twoYearsInDays

#check Rat

-- Assume Day 0 is Jan 1, 2009 for reference
def DATE_2009_01_01 : Day := 0

def checkFrequencyLimit (saleDate : Day) (priorExclusions : List Day) : Bool :=
  let twoYearsAgo := saleDate - 730
  priorExclusions.any (fun d => d > twoYearsAgo && d < saleDate)

def getLastUseDate (history : PropertyHistory) : Option Day :=
  history.usePeriods.foldl (fun acc p =>
    match acc with
    | none => some p.finish
    | some d => some (max d p.finish)
  ) none

def calculateNonqualifiedUseRatio (history : PropertyHistory) (saleDate : Day) : Rat :=
  let totalOwnershipDays := (history.ownershipPeriods.map (fun p => p.length)).sum
  if totalOwnershipDays == 0 then 0 else
  let lastUse := getLastUseDate history
  let fiveYearStart := saleDate - 1825
  
  let exceptionZoneStart : Option Day :=
    match lastUse with
    | none => none
    | some last => some (max last fiveYearStart)
  
  let totalNQDays := (history.nonqualifiedUsePeriods.map (fun p =>
    -- 1. Intersect with post-2009
    let start1 := max p.start DATE_2009_01_01
    let finish1 := p.finish
    if start1 >= finish1 then 0 else
    let len1 := finish1 - start1
    
    -- 2. Subtract intersection with exceptionZone
    let deduction :=
      match exceptionZoneStart with
      | none => 0
      | some zStart =>
        -- The exception zone is [zStart, saleDate]
        -- Intersect [start1, finish1] with [zStart, saleDate]
        let iStart := max start1 zStart
        let iFinish := min finish1 saleDate
        if iStart < iFinish then iFinish - iStart else 0
    
    len1 - deduction
  )).sum
  
  Rat.divInt totalNQDays totalOwnershipDays

def currencyToRat (c : Currency) : Rat := Int.cast c

structure Taxpayer where
  priorExclusions : List Day
  history : PropertyHistory
  deriving DecidableEq, Repr

def checkJointReturnRequirements (t1 t2 : Taxpayer) (saleDate : Day) : Bool :=
  let own1 := checkOwnership t1.history saleDate
  let own2 := checkOwnership t2.history saleDate
  let cond_i := own1 || own2
  let use1 := checkUse t1.history saleDate
  let use2 := checkUse t2.history saleDate
  let cond_ii := use1 && use2
  let freq1 := checkFrequencyLimit saleDate t1.priorExclusions
  let freq2 := checkFrequencyLimit saleDate t2.priorExclusions
  let cond_iii := !freq1 && !freq2
  cond_i && cond_ii && cond_iii

def calculateExclusionLimit
  (filingStatus : FilingStatus)
  (t1 : Taxpayer)
  (t2 : Option Taxpayer)
  (saleDate : Day)
  (spouseDeathDate : Option Day) : Currency :=
  match filingStatus with
  | FilingStatus.MarriedFilingJointly =>
    match t2 with
    | some spouse =>
      if checkJointReturnRequirements t1 spouse saleDate then
        limitJoint
      else
        let limit1 := if checkOwnership t1.history saleDate && checkUse t1.history saleDate && !checkFrequencyLimit saleDate t1.priorExclusions then limitSingle else 0
        let limit2 := if checkOwnership spouse.history saleDate && checkUse spouse.history saleDate && !checkFrequencyLimit saleDate spouse.priorExclusions then limitSingle else 0
        limit1 + limit2
    | none => limitSingle
  | FilingStatus.QualifyingWidower =>
    match spouseDeathDate with
    | some deathDate =>
      if saleDate <= deathDate + 730 then
        match t2 with
        | some spouse =>
           if checkJointReturnRequirements t1 spouse deathDate then limitJoint else limitSingle
        | none => limitSingle
      else
        limitSingle
    | none => limitSingle
  | _ => limitSingle

def calculateExcludedGain
  (filingStatus : FilingStatus)
  (t1 : Taxpayer)
  (t2 : Option Taxpayer)
  (sale : Sale)
  (spouseDeathDate : Option Day) : Currency :=
  let nqRatio := calculateNonqualifiedUseRatio sale.propertyHistory sale.date
  let totalGainRat : Rat := currencyToRat sale.gain
  let nqGainRat := totalGainRat * nqRatio
  let eligibleGainRat := totalGainRat - nqGainRat
  let eligibleGain : Currency := eligibleGainRat.floor
  let limit := calculateExclusionLimit filingStatus t1 t2 sale.date spouseDeathDate
  if eligibleGain <= limit then eligibleGain else limit

theorem exclusion_limit_nonneg
  (filingStatus : FilingStatus)
  (t1 : Taxpayer)
  (t2 : Option Taxpayer)
  (saleDate : Day)
  (spouseDeathDate : Option Day) :
  calculateExclusionLimit filingStatus t1 t2 saleDate spouseDeathDate ≥ 0 := by
  -- The exclusion limit is either 250,000 or 500,000, both of which are non-negative.
  cases filingStatus <;> norm_num [ calculateExclusionLimit ];
  · exact Int.ofNat_zero_le _;
  · cases t2 <;> simp +decide [ * ];
    · exact Int.ofNat_le.2 ( by decide );
    · -- In all cases, the result is non-negative.
      apply Int.le_of_lt_add_one; aesop;
      · native_decide +revert;
      · decide +revert;
      · decide +revert;
      · native_decide +revert;
      · decide +revert;
  · exact Int.ofNat_zero_le _;
  · exact Int.ofNat_zero_le _;
  · -- Since the limit is either 250,000 or 500,000, and both are positive, the limit is non-negative.
    cases' spouseDeathDate with deathDate
    all_goals generalize_proofs at *;
    · exact le_of_lt ( by decide : ( 0 : ℤ ) < 250000 );
    · cases t2 <;> aesop;
      · exact Int.ofNat_le.mpr ( by decide );
      · exact Int.ofNat_le.mpr ( by decide );
      · exact Int.ofNat_zero_le _;
      · exact Int.le_of_lt_add_one ( by decide )

theorem excluded_gain_le_limit
  (filingStatus : FilingStatus)
  (t1 : Taxpayer)
  (t2 : Option Taxpayer)
  (sale : Sale)
  (spouseDeathDate : Option Day) :
  calculateExcludedGain filingStatus t1 t2 sale spouseDeathDate <=
  calculateExclusionLimit filingStatus t1 t2 sale.date spouseDeathDate := by
  -- By definition of `calculateExcludedGain`, it is either the eligible gain or the exclusion limit.
  unfold calculateExcludedGain;
  -- By definition of `calculateExcludedGain`, it is either the eligible gain or the exclusion limit. Therefore, we can split into two cases.
  cases' h : calculateExclusionLimit filingStatus t1 t2 sale.date spouseDeathDate with h h;
  · -- Since the eligible gain is either the eligible gain or the limit, and the limit is h✝, the if statement will always return a value that's less than or equal to h✝.
    aesop;
    -- The hypothesis h_2 is a negation of the inequality we're trying to prove, so it can't be used to derive a contradiction.
    by_contra h_contra;
    -- Apply the contradiction in h_contra to derive False.
    apply h_contra; exact le_refl (h_1 : ℤ);
  · -- Since the exclusion limit is non-negative, the case where it is negative cannot occur.
    have h_nonneg : 0 ≤ calculateExclusionLimit filingStatus t1 t2 sale.date spouseDeathDate := by
      -- Apply the fact that the exclusion limit is non-negative.
      apply exclusion_limit_nonneg;
    -- Since the exclusion limit is non-negative, the case where it is negative cannot occur. Therefore, we can discard this case.
    aesop;
    -- Since `Int.negSucc h_1` is negative, the inequality `0 ≤ Int.negSucc h_1` is false.
    norm_cast at h_nonneg

theorem excluded_gain_le_total_gain
  (filingStatus : FilingStatus)
  (t1 : Taxpayer)
  (t2 : Option Taxpayer)
  (sale : Sale)
  (spouseDeathDate : Option Day)
  (h_gain_nonneg : sale.gain >= 0) :
  calculateExcludedGain filingStatus t1 t2 sale spouseDeathDate <= sale.gain := by
  -- The eligible gain is less than or equal to the total gain because it is adjusted for nonqualified use.
  have h_eligible_gain_le_total : (calculateNonqualifiedUseRatio sale.propertyHistory sale.date : Rat) ≥ 0 := by
    -- The nonqualified use ratio is non-negative because it is a ratio of positive numbers.
    simp [calculateNonqualifiedUseRatio];
    split_ifs <;> norm_cast;
    rw [ Rat.divInt_eq_div, le_div_iff₀ ] <;> norm_cast;
    · norm_num +zetaDelta at *;
      refine' List.sum_nonneg _;
      aesop;
      cases h : getLastUseDate sale.propertyHistory <;> aesop;
      · linarith;
      · linarith;
      · omega;
      · linarith;
      · linarith;
    · exact lt_of_le_of_ne ( List.sum_nonneg <| by aesop ; exact sub_nonneg.mpr <| by linarith [ TimePeriod.h_order ‹_› ] ) ( Ne.symm ‹_› );
  -- Since the eligible gain is less than or equal to the total gain, and the floor function preserves the inequality, we have:
  have h_floor_le_total : ((currencyToRat sale.gain) - (currencyToRat sale.gain) * calculateNonqualifiedUseRatio sale.propertyHistory sale.date).floor ≤ sale.gain := by
    exact Int.floor_mono <| sub_le_self _ <| mul_nonneg ( Int.cast_nonneg.mpr h_gain_nonneg ) h_eligible_gain_le_total;
  unfold calculateExcludedGain; aesop;
  exact le_trans ( le_of_not_ge h ) h_floor_le_total
/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f5a78caf-492a-4e19-b38e-6665b939d2aa
-/

/-
Formalization of IRC Section 482 in Lean 4.
This module defines the structures and functions necessary to model the allocation of income and deductions among taxpayers owned or controlled by the same interests.
It includes definitions for Organizations, ControlGroups, IntangibleProperty, and Transfers.
It implements the logic for the Secretary's authority to allocate income/deductions to prevent tax evasion or clearly reflect income.
It also covers the "commensurate with income" standard for intangible property transfers and the requirement to use the most reliable valuation method (aggregate or realistic alternatives).
Theorems are provided to verify that the allocation mechanisms preserve total income, deductions, credits, and allowances within the control group, and that adjustments to intangible transfers result in commensurate pricing.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for Currency, TaxYear, and FilingStatus as requested.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Definitions for Organization and ControlGroup to model the entities in IRC §482. An Organization has income, deductions, credits, and allowances. A ControlGroup consists of two or more organizations controlled by the same interests.
-/
instance : Repr Currency := inferInstanceAs (Repr Int)

structure Organization where
  id : String
  gross_income : Currency
  deductions : Currency
  credits : Currency
  allowances : Currency
  deriving DecidableEq, Repr

-- Represents a group of organizations controlled by the same interests
structure ControlGroup where
  members : List Organization
  h_two_or_more : members.length ≥ 2
  deriving Repr

/-
Definitions for IntangibleProperty and Transfer. A Transfer involves an intangible property moving from a source organization to a destination organization, with an associated income attributable to the intangible and a reported price.
-/
structure IntangibleProperty where
  id : String
  description : String
  deriving DecidableEq, Repr

structure Transfer where
  property : IntangibleProperty
  source : Organization
  destination : Organization
  income_attributable : Currency
  reported_price : Currency
  deriving Repr

/-
Defines `isCommensurate` to check if the reported price of a transfer matches the income attributable to the intangible. Defines `adjustTransfer` to correct the reported price to match the attributable income. States a theorem that the adjusted transfer is commensurate.
-/
def isCommensurate (t : Transfer) : Bool :=
  t.reported_price == t.income_attributable

def adjustTransfer (t : Transfer) : Transfer :=
  { t with reported_price := t.income_attributable }

theorem adjustTransfer_is_commensurate (t : Transfer) :
  isCommensurate (adjustTransfer t) = true := by
  -- By definition of `adjustTransfer`, we know that the reported price is set to the income attributable to the intangible property.
  simp [adjustTransfer];
  -- By definition of `isCommensurate`, we need to show that the reported price equals the income attributable.
  simp [isCommensurate]

/-
Defines `ValuationMethod` and a function `determineReliableMethod` to model the Secretary's choice. States a theorem `valuation_requirement` capturing the logic that if a method is determined reliable (prioritizing aggregate), it is selected.
-/
inductive ValuationMethod
  | Aggregate
  | RealisticAlternatives
  | Other
  deriving DecidableEq, Repr

-- Represents the Secretary's determination of the most reliable valuation method
def determineReliableMethod (aggregateReliable : Bool) (realisticReliable : Bool) : ValuationMethod :=
  if aggregateReliable then ValuationMethod.Aggregate
  else if realisticReliable then ValuationMethod.RealisticAlternatives
  else ValuationMethod.Other

-- IRC §482: The Secretary shall require valuation on aggregate or realistic alternatives basis
-- if determined to be the most reliable.
theorem valuation_requirement (aggregateReliable : Bool) (realisticReliable : Bool) :
  let method := determineReliableMethod aggregateReliable realisticReliable
  (aggregateReliable → method = ValuationMethod.Aggregate) ∧
  (¬aggregateReliable ∧ realisticReliable → method = ValuationMethod.RealisticAlternatives) := by
  cases aggregateReliable <;> cases realisticReliable <;> tauto

/-
Defines `AllocationReason` and `applySection482` to model the Secretary's authority to allocate income/deductions if necessary to prevent evasion or clearly reflect income. Includes a validity check `isValidReallocation` (simplified). States theorem `section482_authority`.
-/
inductive AllocationReason
  | EvasionOfTaxes
  | ClearlyReflectIncome
  | None
  deriving DecidableEq, Repr

-- Checks if the reallocation is valid (i.e., involves the same organizations)
def isValidReallocation (original : List Organization) (proposed : List Organization) : Bool :=
  let originalIds := original.map Organization.id
  let proposedIds := proposed.map Organization.id
  -- Sort or set equality would be better, but for now just checking length and containment or simple equality of IDs if order is preserved
  -- Let's assume order might change, so we check if they are permutations.
  -- For simplicity in this formalization, let's assume the proposed allocation preserves the list order or we just check length for now to avoid complex List logic dependencies.
  original.length == proposed.length -- Simplified check

-- IRC §482: Secretary may distribute, apportion, or allocate ... if necessary
def applySection482 (group : ControlGroup) (proposed_allocation : List Organization) (reason : AllocationReason) : List Organization :=
  if reason != AllocationReason.None && isValidReallocation group.members proposed_allocation then
    proposed_allocation
  else
    group.members

theorem section482_authority (group : ControlGroup) (proposed : List Organization) (reason : AllocationReason) :
  reason ≠ AllocationReason.None → isValidReallocation group.members proposed →
  applySection482 group proposed reason = proposed := by
  unfold applySection482; aesop

/-
Adds necessary typeclass instances for `Currency` (Add, Sub, Neg, OfNat). Defines `totalGrossIncome` and `totalDeductions` for a list of organizations. States a theorem `allocation_preserves_total_income` asserting that if a valid reallocation is applied, the total gross income remains unchanged (assuming the proposed allocation preserves it).
-/
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Neg Currency := inferInstanceAs (Neg Int)
instance {n : Nat} : OfNat Currency n := inferInstanceAs (OfNat Int n)

def totalGrossIncome (orgs : List Organization) : Currency :=
  orgs.foldl (fun sum org => sum + org.gross_income) (0 : Currency)

def totalDeductions (orgs : List Organization) : Currency :=
  orgs.foldl (fun sum org => sum + org.deductions) (0 : Currency)

theorem allocation_preserves_total_income (group : ControlGroup) (proposed : List Organization) (reason : AllocationReason) :
  reason ≠ AllocationReason.None →
  isValidReallocation group.members proposed →
  totalGrossIncome proposed = totalGrossIncome group.members →
  totalGrossIncome (applySection482 group proposed reason) = totalGrossIncome group.members := by
  unfold applySection482; aesop

/-
Defines functions to calculate total credits and allowances for a list of organizations.
-/
def totalCredits (orgs : List Organization) : Currency :=
  orgs.foldl (fun sum org => sum + org.credits) 0

def totalAllowances (orgs : List Organization) : Currency :=
  orgs.foldl (fun sum org => sum + org.allowances) 0

/-
Theorem stating that if a proposed allocation preserves total deductions, then the result of applying Section 482 also preserves total deductions.
-/
theorem allocation_preserves_total_deductions (group : ControlGroup) (proposed : List Organization) (reason : AllocationReason) :
  reason ≠ AllocationReason.None →
  isValidReallocation group.members proposed →
  totalDeductions proposed = totalDeductions group.members →
  totalDeductions (applySection482 group proposed reason) = totalDeductions group.members := by
  unfold applySection482;
  aesop

/-
Theorem stating that if a proposed allocation preserves total credits, then the result of applying Section 482 also preserves total credits.
-/
theorem allocation_preserves_total_credits (group : ControlGroup) (proposed : List Organization) (reason : AllocationReason) :
  reason ≠ AllocationReason.None →
  isValidReallocation group.members proposed →
  totalCredits proposed = totalCredits group.members →
  totalCredits (applySection482 group proposed reason) = totalCredits group.members := by
  unfold applySection482; aesop;

/-
Theorem stating that if a proposed allocation preserves total allowances, then the result of applying Section 482 also preserves total allowances.
-/
theorem allocation_preserves_total_allowances (group : ControlGroup) (proposed : List Organization) (reason : AllocationReason) :
  reason ≠ AllocationReason.None →
  isValidReallocation group.members proposed →
  totalAllowances proposed = totalAllowances group.members →
  totalAllowances (applySection482 group proposed reason) = totalAllowances group.members := by
  unfold applySection482; aesop;
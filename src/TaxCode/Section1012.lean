/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8f37cf07-fe0f-4449-b1c4-f1690eb47d02
-/

/-
Formalization of IRC Section 1012 (Basis of Property - Cost).

This module defines the necessary types and functions to calculate the basis of property
according to the rules set forth in IRC §1012. It includes:
- Definitions for `Currency`, `TaxYear`, `FilingStatus`, and `Property`.
- Implementation of the general rule that basis is cost (§1012(a)).
- Special rule for real property taxes (§1012(b)).
- Rules for separate accounts and the single account election for stock (§1012(c)).
- Rules for dividend reinvestment plans (DRP) and average basis method (§1012(d)).
- Theorems verifying the correctness of these rules, such as the effect of the single account election.
- Examples demonstrating the usage of these functions.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of Currency, TaxYear, FilingStatus, and Date.
-/
-- Common definitions
/-- Currency amount in cents or smallest unit -/
def Currency := Int

/-- Tax year structure -/
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

/-- Filing status for taxpayers -/
inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

/-- Simple Date structure for comparison -/
structure Date where
  year : Nat
  month : Nat
  day : Nat
  deriving DecidableEq, Repr, Ord

instance : LE Date where
  le a b :=
    if a.year < b.year then true
    else if a.year > b.year then false
    else if a.month < b.month then true
    else if a.month > b.month then false
    else a.day ≤ b.day

instance : LT Date where
  lt a b :=
    if a.year < b.year then true
    else if a.year > b.year then false
    else if a.month < b.month then true
    else if a.month > b.month then false
    else a.day < b.day

instance : DecidableRel (· ≤ · : Date → Date → Prop) := fun a b =>
  if h : (if a.year < b.year then true
          else if a.year > b.year then false
          else if a.month < b.month then true
          else if a.month > b.month then false
          else a.day ≤ b.day) = true
  then isTrue (by
  exact?)
  else isFalse (by
  exact?)

instance : DecidableRel (· < · : Date → Date → Prop) := fun a b =>
  if h : (if a.year < b.year then true
          else if a.year > b.year then false
          else if a.month < b.month then true
          else if a.month > b.month then false
          else a.day < b.day) = true
  then isTrue (by
  -- Since the decide of the less-than predicate is true, we can conclude that a < b in the original order.
  convert h using 1)
  else isFalse (by
  exact?)

/-
Definitions of PropertyType and Property structure with necessary instances for Currency.
-/
-- IRC §1012(c)(3) Definitions
/-- Types of property mentioned in IRC §1012 -/
inductive PropertyType
  | RealProperty
  | Stock (is_regulated_investment_company : Bool) (is_dividend_reinvestment_plan : Bool)
  | Other
  deriving DecidableEq, Repr

instance : Repr Currency := inferInstanceAs (Repr Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)

/-- Structure representing a property -/
structure Property where
  id : String
  type : PropertyType
  cost : Currency
  acquisition_date : Date
  /-- Real estate taxes treated as imposed on taxpayer under §164(d) -/
  real_estate_taxes_paid : Currency
  deriving DecidableEq, Repr

/-- Helper to check if property is a specified security (simplified for this context) -/
def is_specified_security (p : Property) : Bool :=
  match p.type with
  | PropertyType.Stock _ _ => true
  | _ => false

/-
Function to calculate the basis of a property, implementing IRC §1012(a) and (b).
-/
/-- IRC §1012(a) & (b) Basis Calculation
    (a) General rule: Basis is cost.
    (b) Special rule: Cost of real property does not include real estate taxes treated as imposed on taxpayer. -/
def calculate_basis (p : Property) : Currency :=
  match p.type with
  | PropertyType.RealProperty => p.cost - p.real_estate_taxes_paid
  | _ => p.cost

/-
Definition of Account structure and a function to check if average basis is permissible.
-/
/-- Account structure to hold properties -/
structure Account where
  id : String
  holdings : List Property
  is_regulated_investment_company : Bool
  has_elected_single_account : Bool -- Election under §1012(c)(2)(B)
  deriving DecidableEq, Repr

/-- IRC §1012(c)(2) & (d)(1) Average Basis Permissibility
    Checks if average basis method is permissible for a given stock in an account. -/
def is_average_basis_permissible (acct : Account) (p : Property) : Bool :=
  match p.type with
  | PropertyType.Stock is_ric is_drp =>
    -- §1012(c)(2): Permissible for RIC stock
    -- §1012(d)(1): Permissible for DRP stock
    (is_ric || acct.is_regulated_investment_company) || is_drp
  | _ => false

/-
Definition of jan_1_2012, are_separate_accounts, and a theorem verifying the election effect.
-/
/-- January 1, 2012 -/
def jan_1_2012 : Date := { year := 2012, month := 1, day := 1 }

/-- IRC §1012(c)(2) Separate Accounts Rule
    Determines if two properties (stocks) should be treated as being in separate accounts
    based on their acquisition dates and the account's election status. -/
def are_separate_accounts (acct : Account) (p1 p2 : Property) : Bool :=
  match p1.type, p2.type with
  | PropertyType.Stock _ _, PropertyType.Stock _ _ =>
    if acct.has_elected_single_account then
      false -- §1012(c)(2)(B)(i): (A) shall not apply
    else
      -- §1012(c)(2)(A): Pre-2012 and Post-2012 are separate
      let p1_pre := p1.acquisition_date < jan_1_2012
      let p2_pre := p2.acquisition_date < jan_1_2012
      p1_pre != p2_pre
  | _, _ => false -- Not applicable to non-stock or mixed types in this context

/-- Theorem: If election is made, pre-2012 and post-2012 stocks are not separate accounts. -/
theorem election_unifies_accounts (acct : Account) (p1 p2 : Property)
  (h_stock1 : match p1.type with | PropertyType.Stock _ _ => true | _ => false)
  (h_stock2 : match p2.type with | PropertyType.Stock _ _ => true | _ => false)
  (h_election : acct.has_elected_single_account = true) :
  are_separate_accounts acct p1 p2 = false := by
    unfold are_separate_accounts; aesop;

/-
Definitions for transfer basis, average basis calculation, and a master determine_basis function, with explicit Int casting.
-/
instance (n : Nat) : OfNat Currency n := ⟨Int.ofNat n⟩

/-- December 31, 2011 -/
def dec_31_2011 : Date := { year := 2011, month := 12, day := 31 }

/-- IRC §1012(d)(2) Treatment after transfer
    Calculates the new basis after transfer, adjusting for fees. -/
def transfer_basis (old_basis : Currency) (transfer_fees : Currency) : Currency :=
  old_basis + transfer_fees

theorem transfer_basis_zero_fees (b : Currency) :
  transfer_basis b 0 = b := by
    exact Int.add_zero _

/-- Calculates the average basis of properties in an account.
    Returns 0 if account is empty. -/
def calculate_average_basis (acct : Account) : Currency :=
  let total_cost : Int := acct.holdings.foldl (fun sum p => sum + p.cost) 0
  let count : Int := acct.holdings.length
  if count = 0 then 0 else total_cost / count

/-- Method for determining basis -/
inductive BasisMethod
  | SpecificIdentification
  | AverageBasis
  deriving DecidableEq, Repr

/-- Determines the basis of a property using the specified method.
    Falls back to SpecificIdentification (cost) if AverageBasis is not permissible. -/
def determine_basis (acct : Account) (p : Property) (method : BasisMethod) : Currency :=
  match method with
  | BasisMethod.SpecificIdentification => calculate_basis p
  | BasisMethod.AverageBasis =>
    if is_average_basis_permissible acct p then
      calculate_average_basis acct
    else
      calculate_basis p

/-
Theorem verifying that DRP stock allows average basis method.
-/
/-- Theorem: Stock in a Dividend Reinvestment Plan (DRP) is eligible for the Average Basis method.
    This corresponds to IRC §1012(d)(1). -/
theorem drp_stock_allows_average_basis (acct : Account) (p : Property)
  (h_drp : match p.type with | PropertyType.Stock _ is_drp => is_drp = true | _ => false) :
  is_average_basis_permissible acct p = true := by
    -- By definition of `is_average_basis_permissible`, if `p` is a DRP stock, then `is_average_basis_permissible acct p` is true.
    unfold is_average_basis_permissible;
    cases p ; aesop

/-
Examples demonstrating the usage of the formalized IRC §1012 rules.
-/
-- Examples and Tests

/-- Example 1: Real Property Basis Calculation -/
def example_real_property : Property := {
  id := "House",
  type := PropertyType.RealProperty,
  cost := 50000000, -- $500,000.00
  acquisition_date := { year := 2020, month := 1, day := 1 },
  real_estate_taxes_paid := 500000 -- $5,000.00
}

-- Basis should be cost minus taxes paid: 50000000 - 500000 = 49500000
#eval calculate_basis example_real_property

/-- Example 2: Stock Account with Average Basis -/
def stock1 : Property := {
  id := "Stock A",
  type := PropertyType.Stock true false, -- RIC, not DRP
  cost := 10000, -- $100.00
  acquisition_date := { year := 2013, month := 1, day := 1 },
  real_estate_taxes_paid := 0
}

def stock2 : Property := {
  id := "Stock B",
  type := PropertyType.Stock true false, -- RIC, not DRP
  cost := 20000, -- $200.00
  acquisition_date := { year := 2013, month := 2, day := 1 },
  real_estate_taxes_paid := 0
}

def my_account : Account := {
  id := "My Investment Account",
  holdings := [stock1, stock2],
  is_regulated_investment_company := true,
  has_elected_single_account := false
}

-- Average basis: (10000 + 20000) / 2 = 15000
#eval calculate_average_basis my_account

-- Check if average basis is permissible for stock1
#eval is_average_basis_permissible my_account stock1

-- Determine basis using AverageBasis method
#eval determine_basis my_account stock1 BasisMethod.AverageBasis

/-- Example 3: Separate Accounts Rule -/
def old_stock : Property := {
  id := "Old Stock",
  type := PropertyType.Stock true false,
  cost := 10000,
  acquisition_date := { year := 2010, month := 1, day := 1 },
  real_estate_taxes_paid := 0
}

def new_stock : Property := {
  id := "New Stock",
  type := PropertyType.Stock true false,
  cost := 10000,
  acquisition_date := { year := 2013, month := 1, day := 1 },
  real_estate_taxes_paid := 0
}

-- Should be separate accounts (true) because one is pre-2012 and one is post-2012
#eval are_separate_accounts my_account old_stock new_stock

def my_elected_account : Account := {
  id := "My Elected Account",
  holdings := [old_stock, new_stock],
  is_regulated_investment_company := true,
  has_elected_single_account := true
}

-- Should NOT be separate accounts (false) because of election
#eval are_separate_accounts my_elected_account old_stock new_stock
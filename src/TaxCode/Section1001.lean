/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: d1134232-f680-4428-97ef-64b4d1970ca1
-/

/-
Formalization of IRC Section 1001.

This module defines the types and functions necessary to calculate the gain or loss
from the sale or other disposition of property under 26 U.S. Code § 1001.

It includes:
- Type definitions for Currency, TaxYear, FilingStatus, and TermInterest.
- A structure `Disposition` to capture all relevant data for a transaction.
- Functions to calculate `amountRealized` (§1001(b)), `effectiveAdjustedBasis` (including §1001(e) rules), `gain`, and `loss` (§1001(a)).
- Theorems verifying the correctness and consistency of these calculations, such as `gain_nonneg`, `loss_nonneg`, and `gain_minus_loss_eq_realized_minus_basis`.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic type definitions for IRC Section 1001 formalization.
-/
-- Common definitions (inline these if needed)
def Currency := Int
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

/-
Adds instances for `Currency` and defines `TermInterest`, `Disposition`, and `amountRealized`.
-/
-- Instances for Currency to behave like Int
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Neg Currency := inferInstanceAs (Neg Int)
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)

-- IRC §1001(e)(2)
inductive TermInterest
  | LifeInterest
  | TermOfYears
  | IncomeInterestInTrust
  deriving DecidableEq, Repr

-- Structure to hold information about a sale or disposition of property
structure Disposition where
  -- Amounts for §1001(b)
  moneyReceived : Currency
  propertyReceivedFMV : Currency
  reimbursementForPurchaserTaxes : Currency -- §1001(b)(1)
  taxpayerTaxesPaidByPurchaser : Currency   -- §1001(b)(2)
  
  -- Basis information for §1001(a) and (e)
  adjustedBasis : Currency
  basisFromGiftOrInheritance : Currency -- Portion of basis determined under 1014, 1015, or 1041
  
  -- Term interest details for §1001(e)
  termInterest : Option TermInterest
  isEntireInterestTransferred : Bool -- §1001(e)(3)
  deriving DecidableEq, Repr

-- IRC §1001(b) Amount realized
def amountRealized (d : Disposition) : Currency :=
  d.moneyReceived + d.propertyReceivedFMV - d.reimbursementForPurchaserTaxes + d.taxpayerTaxesPaidByPurchaser

/-
Adds missing instances for `Currency` and implements the core calculation logic for adjusted basis, gain, and loss, packaging the results into `GainLossResult`.
-/
-- Additional instances for Currency
instance : LT Currency := inferInstanceAs (LT Int)
instance : LE Currency := inferInstanceAs (LE Int)
-- We need DecidableRel for < and <= to be used in if-statements
instance : DecidableRel (· < · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· < · : Int → Int → Prop))
instance : DecidableRel (· ≤ · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· ≤ · : Int → Int → Prop))
instance (n : Nat) : OfNat Currency n := inferInstanceAs (OfNat Int n)

-- IRC §1001(e)(1) Adjusted basis rule for term interests
def effectiveAdjustedBasis (d : Disposition) : Currency :=
  if d.termInterest.isSome && !d.isEntireInterestTransferred then
    d.adjustedBasis - d.basisFromGiftOrInheritance
  else
    d.adjustedBasis

-- IRC §1001(a) Computation of gain
def gain (d : Disposition) : Currency :=
  let ar := amountRealized d
  let ab := effectiveAdjustedBasis d
  if ar > ab then ar - ab else 0

-- IRC §1001(a) Computation of loss
def loss (d : Disposition) : Currency :=
  let ar := amountRealized d
  let ab := effectiveAdjustedBasis d
  if ab > ar then ab - ar else 0

-- Structure to represent the final result
structure GainLossResult where
  amountRealized : Currency
  adjustedBasis : Currency
  gain : Currency
  loss : Currency
  recognizedGain : Currency -- §1001(c)
  recognizedLoss : Currency -- §1001(c)
  deriving DecidableEq, Repr

-- Function to compute the full result
def calculateGainLoss (d : Disposition) : GainLossResult :=
  let g := gain d
  let l := loss d
  {
    amountRealized := amountRealized d
    adjustedBasis := effectiveAdjustedBasis d
    gain := g
    loss := l
    -- §1001(c) Recognition of gain or loss
    -- "Except as otherwise provided... the entire amount... shall be recognized."
    -- We assume no other non-recognition provisions apply for this basic model.
    recognizedGain := g
    recognizedLoss := l
  }

/-
Theorem stating that the gain from a disposition is always non-negative.
-/
-- Theorem: Gain is always non-negative
theorem gain_nonneg (d : Disposition) : gain d ≥ 0 := by
  unfold gain; aesop;
  · exact Int.sub_nonneg_of_le h.le;
  · decide +revert

/-
Theorem stating that the loss from a disposition is always non-negative.
-/
-- Theorem: Loss is always non-negative
theorem loss_nonneg (d : Disposition) : loss d ≥ 0 := by
  unfold loss;
  aesop;
  · exact Int.sub_nonneg_of_le h.le;
  · native_decide +revert

/-
Theorem stating that gain and loss are mutually exclusive; if gain is positive, loss must be zero.
-/
-- Theorem: Gain and Loss are mutually exclusive (cannot both be positive)
theorem gain_loss_exclusive (d : Disposition) : gain d > 0 → loss d = 0 := by
  unfold loss; aesop;
  -- By definition of `gain`, if `gain d > 0`, then `amountRealized d > effectiveAdjustedBasis d`.
  unfold gain at a;
  unfold Currency at * ; aesop;
  linarith

/-
Helper lemma stating that for any integers a and b, the difference between the positive part of (a-b) and the positive part of (b-a) is equal to (a-b).
-/
-- Helper lemma for integer arithmetic
lemma int_gain_loss_identity (a b : Int) :
  (if a > b then a - b else 0) - (if b > a then b - a else 0) = a - b := by
    split_ifs <;> linarith

/-
Theorem stating that the difference between gain and loss equals the difference between amount realized and adjusted basis.
-/
-- Theorem: Relationship between Gain, Loss, Amount Realized, and Adjusted Basis
theorem gain_minus_loss_eq_realized_minus_basis (d : Disposition) :
  gain d - loss d = amountRealized d - effectiveAdjustedBasis d := by
    exact int_gain_loss_identity _ _
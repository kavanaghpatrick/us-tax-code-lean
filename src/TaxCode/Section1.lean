/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 84b724c2-b03d-46e9-8552-db901d06fe09

Sorry, Aristotle was unable to complete the task in time.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define the basic types for the IRC Section 1 formalization: Currency (as Int, representing cents), TaxYear, and FilingStatus.
-/
-- IRC §1 Formalization

-- 1. Type Definitions

/-- Currency amount in cents. -/
def Currency := Int

/-- Represents a tax year. -/
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq, Repr

/-- Filing status of the taxpayer. -/
inductive FilingStatus
  | Single
  | MarriedFilingJointly
  | MarriedFilingSeparately
  | HeadOfHousehold
  | QualifyingWidower
  deriving DecidableEq, Repr

/-
Define the tax brackets and calculation logic for IRC Section 1, using explicit conversion functions `toCurrency` and `fromCurrency` to handle the `Currency` type. This includes instances for `Currency`, the `TaxBracket` structure, `calculateTax`, and the specific tax tables (a) through (e). Finally, define `section1Tax` which selects the appropriate table based on filing status.
-/
-- We need to handle Currency being a def
def toCurrency (i : Int) : Currency := i
def fromCurrency (c : Currency) : Int := c

instance : Add Currency := ⟨fun a b => toCurrency (fromCurrency a + fromCurrency b)⟩
instance : Sub Currency := ⟨fun a b => toCurrency (fromCurrency a - fromCurrency b)⟩
instance : Mul Currency := ⟨fun a b => toCurrency (fromCurrency a * fromCurrency b)⟩
instance : Div Currency := ⟨fun a b => toCurrency (fromCurrency a / fromCurrency b)⟩
instance : LT Currency := ⟨fun a b => fromCurrency a < fromCurrency b⟩
instance : LE Currency := ⟨fun a b => fromCurrency a ≤ fromCurrency b⟩
instance : DecidableEq Currency := fun a b => decEq (fromCurrency a) (fromCurrency b)
instance : DecidableRel (· < · : Currency → Currency → Prop) := fun a b => Int.decLt (fromCurrency a) (fromCurrency b)
instance : DecidableRel (· ≤ · : Currency → Currency → Prop) := fun a b => Int.decLe (fromCurrency a) (fromCurrency b)
instance : Inhabited Currency := ⟨toCurrency 0⟩
instance {n : Nat} : OfNat Currency n := ⟨toCurrency n⟩
instance : Repr Currency := ⟨fun c n => reprPrec (fromCurrency c) n⟩

-- Helper functions for currency
def usd (dollars : Nat) : Currency := toCurrency ((dollars : Int) * 100)
def usd_cents (dollars : Nat) (cents : Nat) : Currency := toCurrency ((dollars : Int) * 100 + (cents : Int))

/-- Represents a single tax bracket. -/
structure TaxBracket where
  upper : Option Currency -- None means infinity
  baseTax : Currency
  rate : Rat
  excessBase : Currency
  deriving Repr, DecidableEq

/-- Rounds a rational number to the nearest integer (rounding half up). -/
def Rat.roundToNearest (q : Rat) : Int :=
  Int.floor (q + (1 : Rat) / 2)

/-- Calculates tax based on a list of brackets. -/
def calculateTax (income : Currency) (brackets : List TaxBracket) : Currency :=
  match brackets with
  | [] => toCurrency 0
  | b :: bs =>
    match b.upper with
    | some u =>
      if income <= u then
        let excessInt : Int := fromCurrency income - fromCurrency b.excessBase
        let taxFromExcess : Rat := (excessInt : Rat) * b.rate
        toCurrency (fromCurrency b.baseTax + taxFromExcess.roundToNearest)
      else
        calculateTax income bs
    | none =>
      let excessInt : Int := fromCurrency income - fromCurrency b.excessBase
      let taxFromExcess : Rat := (excessInt : Rat) * b.rate
      toCurrency (fromCurrency b.baseTax + taxFromExcess.roundToNearest)

-- Table (a) - Married individuals filing joint returns and surviving spouses
def table_a : List TaxBracket := [
  { upper := some (usd 36900), baseTax := toCurrency 0, rate := (15 : Rat)/100, excessBase := toCurrency 0 },
  { upper := some (usd 89150), baseTax := usd 5535, rate := (28 : Rat)/100, excessBase := usd 36900 },
  { upper := some (usd 140000), baseTax := usd 20165, rate := (31 : Rat)/100, excessBase := usd 89150 },
  { upper := some (usd 250000), baseTax := usd_cents 35928 50, rate := (36 : Rat)/100, excessBase := usd 140000 },
  { upper := none, baseTax := usd_cents 75528 50, rate := (396 : Rat)/1000, excessBase := usd 250000 }
]

-- Table (b) - Heads of households
def table_b : List TaxBracket := [
  { upper := some (usd 29600), baseTax := toCurrency 0, rate := (15 : Rat)/100, excessBase := toCurrency 0 },
  { upper := some (usd 76400), baseTax := usd 4440, rate := (28 : Rat)/100, excessBase := usd 29600 },
  { upper := some (usd 127500), baseTax := usd 17544, rate := (31 : Rat)/100, excessBase := usd 76400 },
  { upper := some (usd 250000), baseTax := usd 33385, rate := (36 : Rat)/100, excessBase := usd 127500 },
  { upper := none, baseTax := usd 77485, rate := (396 : Rat)/1000, excessBase := usd 250000 }
]

-- Table (c) - Unmarried individuals (other than surviving spouses and heads of households)
def table_c : List TaxBracket := [
  { upper := some (usd 22100), baseTax := toCurrency 0, rate := (15 : Rat)/100, excessBase := toCurrency 0 },
  { upper := some (usd 53500), baseTax := usd 3315, rate := (28 : Rat)/100, excessBase := usd 22100 },
  { upper := some (usd 115000), baseTax := usd 12107, rate := (31 : Rat)/100, excessBase := usd 53500 },
  { upper := some (usd 250000), baseTax := usd 31172, rate := (36 : Rat)/100, excessBase := usd 115000 },
  { upper := none, baseTax := usd 79772, rate := (396 : Rat)/1000, excessBase := usd 250000 }
]

-- Table (d) - Married individuals filing separate returns
def table_d : List TaxBracket := [
  { upper := some (usd 18450), baseTax := toCurrency 0, rate := (15 : Rat)/100, excessBase := toCurrency 0 },
  { upper := some (usd 44575), baseTax := usd_cents 2767 50, rate := (28 : Rat)/100, excessBase := usd 18450 },
  { upper := some (usd 70000), baseTax := usd_cents 10082 50, rate := (31 : Rat)/100, excessBase := usd 44575 },
  { upper := some (usd 125000), baseTax := usd_cents 17964 25, rate := (36 : Rat)/100, excessBase := usd 70000 },
  { upper := none, baseTax := usd_cents 37764 25, rate := (396 : Rat)/1000, excessBase := usd 125000 }
]

-- Table (e) - Estates and trusts
def table_e : List TaxBracket := [
  { upper := some (usd 1500), baseTax := toCurrency 0, rate := (15 : Rat)/100, excessBase := toCurrency 0 },
  { upper := some (usd 3500), baseTax := usd 225, rate := (28 : Rat)/100, excessBase := usd 1500 },
  { upper := some (usd 5500), baseTax := usd 785, rate := (31 : Rat)/100, excessBase := usd 3500 },
  { upper := some (usd 7500), baseTax := usd 1405, rate := (36 : Rat)/100, excessBase := usd 5500 },
  { upper := none, baseTax := usd 2125, rate := (396 : Rat)/1000, excessBase := usd 7500 }
]

/-- Main tax calculation function for Section 1. -/
def section1Tax (status : FilingStatus) (taxableIncome : Currency) : Currency :=
  let brackets := match status with
    | FilingStatus.MarriedFilingJointly => table_a
    | FilingStatus.QualifyingWidower => table_a
    | FilingStatus.HeadOfHousehold => table_b
    | FilingStatus.Single => table_c
    | FilingStatus.MarriedFilingSeparately => table_d
  calculateTax taxableIncome brackets

/-
Prove that `Rat.roundToNearest q` is non-negative if `q` is non-negative.
-/
/-- Helper lemma: Rounding a non-negative rational number results in a non-negative integer. -/
lemma Rat.roundToNearest_nonneg {q : Rat} (h : q ≥ 0) : Rat.roundToNearest q ≥ 0 := by
  exact Int.floor_nonneg.mpr ( by linarith )

/-
Prove that the tax calculated is always non-negative if the income is non-negative. Use the helper lemma `Rat.roundToNearest_nonneg` to handle the rounding.
-/
/-- Tax is always non-negative for non-negative income. -/
theorem tax_nonnegative (status : FilingStatus) (income : Currency) :
  income ≥ toCurrency 0 → section1Tax status income ≥ toCurrency 0 := by
  induction status <;> aesop;
  · unfold section1Tax;
    unfold table_c; unfold calculateTax; aesop;
    · exact le_add_of_le_of_nonneg ( by trivial ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| Int.cast_le.mpr a ) <| by norm_num );
    · unfold calculateTax; aesop;
      · exact add_nonneg ( by native_decide ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h ) <| by norm_num );
      · unfold calculateTax; aesop;
        · exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h_1 ) <| by norm_num );
        · unfold calculateTax; aesop;
          · -- Since $income > usd 115000$, we have $income - usd 115000 > 0$, and thus the tax calculated is non-negative.
            have h_pos : 0 ≤ (fromCurrency income - fromCurrency (usd 115000)) * (36 / 100 : ℚ) := by
              exact mul_nonneg ( sub_nonneg_of_le <| mod_cast le_of_not_ge h_2 ) <| by norm_num;
            unfold toCurrency; aesop;
            exact add_nonneg ( by native_decide ) ( Rat.roundToNearest_nonneg ( by exact mul_nonneg ( sub_nonneg.mpr ( mod_cast h_pos ) ) ( by norm_num ) ) );
          · unfold calculateTax; aesop;
            unfold toCurrency at *;
            field_simp;
            exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg ( by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr ( mod_cast le_of_not_ge h_3 ) ) ( by norm_num ) ) ( by norm_num ) ) );
  · unfold section1Tax;
    unfold table_a;
    unfold calculateTax; aesop;
    · unfold toCurrency fromCurrency; aesop;
      exact Rat.roundToNearest_nonneg ( mul_nonneg ( Int.cast_nonneg.mpr a ) ( by norm_num ) );
    · unfold calculateTax; aesop;
      · exact add_nonneg ( Int.ofNat_zero_le _ ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h ) <| by norm_num );
      · unfold calculateTax; aesop;
        · exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h_1 ) <| by norm_num );
        · unfold calculateTax; aesop;
          · field_simp;
            exact add_nonneg ( Int.ofNat_zero_le _ ) ( Rat.roundToNearest_nonneg <| by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| mod_cast by { exact le_of_not_ge fun h => h_2 <| by { exact le_trans h <| by { exact le_rfl } } } ) <| by norm_num ) <| by norm_num );
          · unfold calculateTax; aesop;
            field_simp;
            exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| by exact div_nonneg ( mul_nonneg ( sub_nonneg_of_le <| mod_cast le_of_not_ge h_3 ) <| by norm_num ) <| by norm_num );
  · unfold section1Tax table_d;
    unfold calculateTax; aesop;
    · unfold toCurrency fromCurrency at * ; aesop;
      exact Rat.roundToNearest_nonneg ( by positivity );
    · unfold calculateTax; aesop;
      · -- Since the income is non-negative, the excess base is also non-negative. The rate is 28%, which is positive. So multiplying a non-negative number by a positive number gives a non-negative result. Then adding the base tax, which is also non-negative, should keep the total non-negative.
        have h_nonneg : 0 ≤ (fromCurrency income - fromCurrency (usd 18450)) * (28 / 100 : ℚ) := by
          exact mul_nonneg ( sub_nonneg_of_le <| mod_cast le_of_not_ge h ) <| by norm_num;
        unfold toCurrency; aesop;
        exact add_nonneg ( by native_decide ) ( Rat.roundToNearest_nonneg ( mul_nonneg ( sub_nonneg.mpr ( mod_cast h_nonneg ) ) ( by norm_num ) ) );
      · unfold calculateTax; aesop;
        · exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.2 <| mod_cast le_of_not_ge h_1 ) <| by norm_num );
        · unfold calculateTax; aesop;
          · exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg ( mul_nonneg ( sub_nonneg.mpr <| mod_cast by exact le_of_not_ge fun hi => h_2 <| mod_cast hi ) <| by norm_num ) );
          · unfold calculateTax; aesop;
            exact add_nonneg ( by decide ) ( Rat.roundToNearest_nonneg ( mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h_3 ) <| by norm_num ) );
  · unfold section1Tax; aesop;
    unfold calculateTax; unfold table_b; aesop;
    · unfold toCurrency fromCurrency at * ; norm_num at *;
      exact Rat.roundToNearest_nonneg ( by positivity );
    · unfold calculateTax; aesop;
      · exact add_nonneg ( by decide ) ( Rat.roundToNearest_nonneg ( mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h ) <| by norm_num ) );
      · unfold calculateTax; aesop;
        · field_simp;
          exact add_nonneg ( by native_decide ) ( Rat.roundToNearest_nonneg <| div_nonneg ( mul_nonneg ( sub_nonneg_of_le <| mod_cast by { exact le_of_not_gt fun hi => h_1 <| by { exact le_trans hi.le <| by native_decide } } ) <| by norm_num ) <| by norm_num );
        · unfold calculateTax; aesop;
          · refine' Int.add_nonneg _ _;
            · native_decide +revert;
            · refine' Rat.roundToNearest_nonneg _;
              exact mul_nonneg ( sub_nonneg_of_le <| mod_cast by exact le_of_not_ge h_2 ) <| by norm_num;
          · unfold calculateTax; aesop;
            exact add_nonneg ( by decide ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg_of_le <| mod_cast le_of_not_ge h_3 ) <| by norm_num );
  · -- Let's unfold the definition of `calculateTax` and use the fact that the base tax and exceed base are non-negative.
    unfold section1Tax
    simp [table_a, calculateTax];
    aesop;
    · unfold toCurrency fromCurrency; aesop;
      exact Rat.roundToNearest_nonneg ( mul_nonneg ( Int.cast_nonneg.mpr a ) ( by norm_num ) );
    · exact add_nonneg ( Int.ofNat_zero_le _ ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h ) <| by norm_num );
    · exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| mul_nonneg ( sub_nonneg.mpr <| mod_cast le_of_not_ge h_1 ) <| by norm_num );
    · field_simp;
      exact add_nonneg ( Int.ofNat_zero_le _ ) ( Rat.roundToNearest_nonneg <| by exact div_nonneg ( mul_nonneg ( sub_nonneg.mpr <| mod_cast by { exact le_of_not_ge fun h => h_2 <| by { exact le_trans h <| by { exact le_rfl } } } ) <| by norm_num ) <| by norm_num );
    · field_simp;
      exact add_nonneg ( by norm_cast ) ( Rat.roundToNearest_nonneg <| by exact div_nonneg ( mul_nonneg ( sub_nonneg_of_le <| mod_cast le_of_not_ge h_3 ) <| by norm_num ) <| by norm_num )

/-
Prove that the rounding function `Rat.roundToNearest` is monotonic: if `p ≤ q`, then `roundToNearest p ≤ roundToNearest q`.
-/
/-- Helper lemma: Rounding is monotonic. -/
lemma Rat.roundToNearest_mono {p q : Rat} (h : p ≤ q) : Rat.roundToNearest p ≤ Rat.roundToNearest q := by
  unfold Rat.roundToNearest;
  gcongr

/-
Define `taxInBracket` to encapsulate the calculation logic for a single bracket, and prove that it is monotonic with respect to income provided the tax rate is non-negative.
-/
/-- Helper definition for tax calculation within a bracket. -/
def taxInBracket (income : Currency) (b : TaxBracket) : Currency :=
  let excessInt : Int := fromCurrency income - fromCurrency b.excessBase
  let taxFromExcess : Rat := (excessInt : Rat) * b.rate
  toCurrency (fromCurrency b.baseTax + taxFromExcess.roundToNearest)

/-- Lemma: taxInBracket is monotonic if rate is non-negative. -/
lemma taxInBracket_mono {b : TaxBracket} (h_rate : b.rate ≥ 0) (i1 i2 : Currency) (h : i1 ≤ i2) :
  taxInBracket i1 b ≤ taxInBracket i2 b := by
  exact Int.add_le_add_left ( Rat.roundToNearest_mono <| mul_le_mul_of_nonneg_right ( mod_cast by aesop ) h_rate ) _

/-
Prove that if a tax bracket has no upper limit (i.e., it applies to all income above a certain amount) and the tax rate is non-negative, then the tax calculation for that bracket is monotonic with respect to income. This relies on the previously proven `taxInBracket_mono` lemma.
-/
/-- Lemma: If the bracket has no upper bound and non-negative rate, tax calculation is monotonic. -/
lemma calculateTax_none {b : TaxBracket} {bs : List TaxBracket} (h_none : b.upper = none) (h_rate : b.rate ≥ 0) :
  ∀ i1 i2 : Currency, i1 ≤ i2 → calculateTax i1 (b :: bs) ≤ calculateTax i2 (b :: bs) := by
  intro i1 i2 h
  unfold calculateTax
  rw [h_none]
  exact taxInBracket_mono h_rate i1 i2 h
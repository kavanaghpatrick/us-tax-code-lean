/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: c49f5836-e4d1-4f99-b47c-3829662b8ed5
-/

/-
Formalization of IRC Section 1 (Tax Imposed) in Lean 4.
Includes definitions for Currency, TaxYear, and FilingStatus.
Implements tax calculation functions for subsections (a) through (e).
Proves properties such as non-negativity, monotonicity, and continuity of the tax functions.
Includes verified examples for specific income levels.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definitions of Currency, TaxYear, and FilingStatus for IRC Section 1. Currency is defined as Int (interpreted as cents). TaxYear requires year >= 1913. FilingStatus covers all categories in Section 1.
-/
/-- Currency is represented as Int (cents or dollars? The text uses dollars and cents.
    The user said `def Currency := Int`. I will assume this represents the atomic unit or just dollars if no cents are involved,
    but the text has "$35,928.50". So `Currency` likely needs to handle cents.
    However, `Int` doesn't handle decimals directly.
    If I use `Int`, I should probably represent cents.
    But the user simply said `def Currency := Int`.
    If I use dollars, I lose precision on "$35,928.50".
    I will assume `Currency` represents cents to maintain precision, or I will use `Rat` for calculations and cast to `Currency`?
    The user said "Use precise arithmetic".
    Let's interpret `Currency` as `Rat`? No, user explicitly said `def Currency := Int`.
    Okay, I will interpret `Currency` as *cents* to handle the .50.
    $36,900 -> 3690000 cents.
    $35,928.50 -> 3592850 cents.
    This seems the most robust way to use `Int`.
    I will document this assumption.
-/
def Currency := Int

/-- TaxYear structure as requested -/
structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

/-- Filing statuses mentioned in IRC §1 -/
inductive FilingStatus
  | Single                      -- §1(c)
  | MarriedFilingJointly        -- §1(a)(1)
  | MarriedFilingSeparately     -- §1(d)
  | HeadOfHousehold             -- §1(b)
  | QualifyingWidower           -- §1(a)(2) "Surviving Spouse"
  | Estate                      -- §1(e)(1)
  | Trust                       -- §1(e)(2)
  deriving DecidableEq, Repr

/-
Adding typeclass instances for Currency to make it behave like Int. Fixed the syntax error in OfNat instance.
-/
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance : Repr Currency := inferInstanceAs (Repr Int)
instance {n} : OfNat Currency n := inferInstanceAs (OfNat Int n)
instance : DecidableRel (LE.le : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (LE.le : Int → Int → Prop))
instance : DecidableRel (LT.lt : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (LT.lt : Int → Int → Prop))
instance : LinearOrder Currency := inferInstanceAs (LinearOrder Int)

/-
Defining helper functions for currency conversion and percentage calculation, using explicit casting functions `toCurrency` and `fromCurrency` to ensure type compatibility between `Int` and `Currency`.
-/
/-- Helper to cast Int to Currency -/
def toCurrency (i : Int) : Currency := i

/-- Helper to cast Currency to Int -/
def fromCurrency (c : Currency) : Int := c

/-- Helper to convert dollars to cents -/
def dollars (d : Int) : Currency := toCurrency (d * 100)

/-- Helper to convert dollars and cents to cents -/
def dollars_and_cents (d : Int) (c : Int) : Currency := toCurrency (d * 100 + c)

/-- Helper to calculate percentage: (amount * rate) / denominator -/
def calculate_percent (amount : Currency) (rate : Int) (denominator : Int) : Currency :=
  (amount * toCurrency rate) / toCurrency denominator

/-
Implementation of tax calculation functions for each subsection (a) through (e) of IRC Section 1, and a main dispatch function.
Using helper functions `dollars`, `dollars_and_cents`, and `calculate_percent` to handle `Currency` (Int) arithmetic.
The logic follows the tables provided in the text.
-/
/-- Section 1(a) Married individuals filing joint returns and surviving spouses -/
def tax_section1_a (income : Currency) : Currency :=
  if income <= dollars 36900 then
    calculate_percent income 15 100
  else if income <= dollars 89150 then
    dollars 5535 + calculate_percent (income - dollars 36900) 28 100
  else if income <= dollars 140000 then
    dollars 20165 + calculate_percent (income - dollars 89150) 31 100
  else if income <= dollars 250000 then
    dollars_and_cents 35928 50 + calculate_percent (income - dollars 140000) 36 100
  else
    dollars_and_cents 75528 50 + calculate_percent (income - dollars 250000) 396 1000

/-- Section 1(b) Heads of households -/
def tax_section1_b (income : Currency) : Currency :=
  if income <= dollars 29600 then
    calculate_percent income 15 100
  else if income <= dollars 76400 then
    dollars 4440 + calculate_percent (income - dollars 29600) 28 100
  else if income <= dollars 127500 then
    dollars 17544 + calculate_percent (income - dollars 76400) 31 100
  else if income <= dollars 250000 then
    dollars 33385 + calculate_percent (income - dollars 127500) 36 100
  else
    dollars 77485 + calculate_percent (income - dollars 250000) 396 1000

/-- Section 1(c) Unmarried individuals (other than surviving spouses and heads of households) -/
def tax_section1_c (income : Currency) : Currency :=
  if income <= dollars 22100 then
    calculate_percent income 15 100
  else if income <= dollars 53500 then
    dollars 3315 + calculate_percent (income - dollars 22100) 28 100
  else if income <= dollars 115000 then
    dollars 12107 + calculate_percent (income - dollars 53500) 31 100
  else if income <= dollars 250000 then
    dollars 31172 + calculate_percent (income - dollars 115000) 36 100
  else
    dollars 79772 + calculate_percent (income - dollars 250000) 396 1000

/-- Section 1(d) Married individuals filing separate returns -/
def tax_section1_d (income : Currency) : Currency :=
  if income <= dollars 18450 then
    calculate_percent income 15 100
  else if income <= dollars 44575 then
    dollars_and_cents 2767 50 + calculate_percent (income - dollars 18450) 28 100
  else if income <= dollars 70000 then
    dollars_and_cents 10082 50 + calculate_percent (income - dollars 44575) 31 100
  else if income <= dollars 125000 then
    dollars_and_cents 17964 25 + calculate_percent (income - dollars 70000) 36 100
  else
    dollars_and_cents 37764 25 + calculate_percent (income - dollars 125000) 396 1000

/-- Section 1(e) Estates and trusts -/
def tax_section1_e (income : Currency) : Currency :=
  if income <= dollars 1500 then
    calculate_percent income 15 100
  else if income <= dollars 3500 then
    dollars 225 + calculate_percent (income - dollars 1500) 28 100
  else if income <= dollars 5500 then
    dollars 785 + calculate_percent (income - dollars 3500) 31 100
  else if income <= dollars 7500 then
    dollars 1405 + calculate_percent (income - dollars 5500) 36 100
  else
    dollars 2125 + calculate_percent (income - dollars 7500) 396 1000

/-- Main tax calculation function dispatching on filing status -/
def calculate_tax (status : FilingStatus) (income : Currency) : Currency :=
  match status with
  | FilingStatus.MarriedFilingJointly => tax_section1_a income
  | FilingStatus.QualifyingWidower => tax_section1_a income
  | FilingStatus.HeadOfHousehold => tax_section1_b income
  | FilingStatus.Single => tax_section1_c income
  | FilingStatus.MarriedFilingSeparately => tax_section1_d income
  | FilingStatus.Estate => tax_section1_e income
  | FilingStatus.Trust => tax_section1_e income

/-
Theorem stating that tax is non-negative for non-negative income.
-/
/-- Theorem: Tax is non-negative for non-negative income -/
theorem tax_nonnegative (status : FilingStatus) (income : Currency) (h : income ≥ 0) :
  calculate_tax status income ≥ 0 := by
    unfold calculate_tax; aesop;
    -- By definition of `tax_section1_a`, we know that it is non-negative for non-negative incomes.
    have h_nonneg_a : ∀ (income : Currency), 0 ≤ income → 0 ≤ tax_section1_a income := by
      unfold tax_section1_a; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg a ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg_of_le h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_4.le ) ( by decide ) ) ( by decide ) );
    exact?;
    have h_nonneg_a : ∀ (income : Currency), 0 ≤ income → 0 ≤ tax_section1_a income := by
      unfold tax_section1_a; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg a ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg_of_le h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_4.le ) ( by decide ) ) ( by decide ) )
    exact h_nonneg_a income h;
    · unfold tax_section1_b; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg h ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_4.le ) ( by decide ) ) ( by decide ) );
    · unfold tax_section1_c; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg h ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by native_decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.2 h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.2 h_4.le ) ( by decide ) ) ( by decide ) );
    · unfold tax_section1_d;
      unfold dollars_and_cents calculate_percent; split_ifs <;> norm_num;
      · exact Int.ediv_nonneg ( mul_nonneg h ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr <| le_of_not_ge ‹_› ) <| by decide ) <| by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr ( le_of_not_ge ‹¬income ≤ dollars 44575› ) ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr <| le_of_not_ge ‹¬income ≤ dollars 70000› ) <| by decide ) <| by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr ( le_of_not_ge ‹¬income ≤ dollars 125000› ) ) ( by decide ) ) ( by decide ) );
    · unfold tax_section1_e; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg h ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_4.le ) ( by decide ) ) ( by decide ) );
    · unfold tax_section1_e; aesop;
      · exact Int.ediv_nonneg ( mul_nonneg h ( by decide ) ) ( by decide );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_1.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_2.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_3.le ) ( by decide ) ) ( by decide ) );
      · exact add_nonneg ( by decide ) ( Int.ediv_nonneg ( mul_nonneg ( sub_nonneg.mpr h_4.le ) ( by decide ) ) ( by decide ) )

/-
Lemma stating that `calculate_percent` is monotonic with respect to the amount, provided the rate is non-negative and the denominator is positive.
This relies on the monotonicity of integer multiplication (by a non-negative number) and integer division (by a positive number).
-/
/-- Helper lemma: calculate_percent is monotonic in amount when rate >= 0 and denominator > 0 -/
lemma calculate_percent_monotonic (r d : Int) (hr : 0 ≤ r) (hd : 0 < d) :
  Monotone (fun (i : Currency) => calculate_percent i r d) := by
    bound;
    unfold calculate_percent;
    exact fun i j hij => Int.ediv_le_ediv ( by positivity ) ( mul_le_mul_of_nonneg_right hij hr )

/-
Proving continuity at the first boundary of Section 1(a).
This is a direct calculation check.
-/
/-- Theorem: Continuity check for Section 1(a) at $36,900 boundary.
    The tax calculated by the first bracket formula at the boundary
    should equal the base tax of the second bracket. -/
theorem tax_section1_a_boundary_1_continuous :
  calculate_percent (dollars 36900) 15 100 = dollars 5535 := by
    native_decide +revert

/-
Proving continuity at the second boundary of Section 1(a).
This is a direct calculation check.
-/
/-- Theorem: Continuity check for Section 1(a) at $89,150 boundary. -/
theorem tax_section1_a_boundary_2_continuous :
  dollars 5535 + calculate_percent (dollars 89150 - dollars 36900) 28 100 = dollars 20165 := by
    native_decide

/-
Proving continuity at the third boundary of Section 1(a).
This is a direct calculation check.
-/
/-- Theorem: Continuity check for Section 1(a) at $140,000 boundary. -/
theorem tax_section1_a_boundary_3_continuous :
  dollars 20165 + calculate_percent (dollars 140000 - dollars 89150) 31 100 = dollars_and_cents 35928 50 := by
    native_decide +revert

/-
Proving continuity at the fourth boundary of Section 1(a).
This is a direct calculation check.
-/
/-- Theorem: Continuity check for Section 1(a) at $250,000 boundary. -/
theorem tax_section1_a_boundary_4_continuous :
  dollars_and_cents 35928 50 + calculate_percent (dollars 250000 - dollars 140000) 36 100 = dollars_and_cents 75528 50 := by
    -- Calculate the difference in income and apply the tax rate.
    norm_cast

/-
Lemma: The tax calculation for Section 1(a) is monotonic.
This follows from the fact that it is a continuous piecewise linear function with non-negative slopes.
We have already proven continuity at the boundaries.
The slopes are positive percentages.
Integer division is monotonic.
-/
lemma tax_section1_a_monotonic : Monotone tax_section1_a := by
  unfold tax_section1_a;
  unfold calculate_percent; simp +decide [ Monotone ] ;
  norm_num [ dollars, dollars_and_cents, toCurrency ];
  all_goals unfold Currency at *; norm_num at *; omega

/-
Lemma: The tax calculation for Section 1(b) is monotonic.
Similar to Section 1(a), this follows from the piecewise linear structure with positive slopes and continuity (implied by the structure, though not explicitly proven as separate lemmas for (b), the ATP should handle it given the similar structure to (a)).
If it fails, I might need to prove continuity lemmas for (b) as well, but let's try the direct proof first as `tax_section1_a_monotonic` succeeded.
-/
lemma tax_section1_b_monotonic : Monotone tax_section1_b := by
  intros x y hxy;
  unfold tax_section1_b; split_ifs ;
  all_goals unfold calculate_percent at *; norm_num at *;
  all_goals norm_num [ dollars, toCurrency ] at *;
  all_goals unfold Currency at *; norm_num at *;
  all_goals omega

/-
Lemma: The tax calculation for Section 1(c) is monotonic.
This follows from the piecewise linear structure with positive slopes and continuity.
-/
lemma tax_section1_c_monotonic : Monotone tax_section1_c := by
  intro ; aesop;
  unfold tax_section1_c;
  all_goals unfold dollars at *; simp_all +decide [ calculate_percent ];
  all_goals unfold toCurrency at *; norm_num at *;
  all_goals unfold Currency at *; norm_num at *;
  all_goals omega

/-
Lemma: The tax calculation for Section 1(d) is monotonic.
This follows from the piecewise linear structure with positive slopes and continuity.
-/
lemma tax_section1_d_monotonic : Monotone tax_section1_d := by
  unfold Monotone;
  unfold tax_section1_d; intro a b hab; split_ifs;
  all_goals unfold dollars_and_cents at *; unfold calculate_percent at *; norm_num at *;
  all_goals unfold dollars at *; norm_num at *;
  all_goals norm_num [ toCurrency ] at *;
  all_goals unfold Currency at *; norm_num at *;
  all_goals omega

/-
Lemma: The tax calculation for Section 1(e) is monotonic.
This follows from the piecewise linear structure with positive slopes and continuity.
-/
lemma tax_section1_e_monotonic : Monotone tax_section1_e := by
  unfold Monotone tax_section1_e;
  unfold dollars;
  norm_num [ toCurrency, calculate_percent ];
  all_goals unfold Currency at *; norm_num at *;
  all_goals omega

/-
Theorem stating that tax is monotonic (non-decreasing) with respect to income.
Proof splits on filing status and applies the specific monotonicity lemma for each section.
-/
/-- Theorem: Tax is monotonic (non-decreasing) with respect to income -/
theorem tax_monotonic (status : FilingStatus) (i1 i2 : Currency) (h1 : 0 ≤ i1) (h2 : i1 ≤ i2) :
  calculate_tax status i1 ≤ calculate_tax status i2 := by
  cases status <;> simp [calculate_tax]
  · exact tax_section1_c_monotonic h2
  · exact tax_section1_a_monotonic h2
  · exact tax_section1_d_monotonic h2
  · exact tax_section1_b_monotonic h2
  · exact tax_section1_a_monotonic h2
  · exact tax_section1_e_monotonic h2
  · exact tax_section1_e_monotonic h2

/-
Continuity checks for Section 1(b) Head of Household.
Verifying that the tax calculated at the top of each bracket matches the base tax of the next bracket.
-/
/-- Theorem: Continuity check for Section 1(b) at $29,600 boundary. -/
theorem tax_section1_b_boundary_1_continuous :
  calculate_percent (dollars 29600) 15 100 = dollars 4440 := by native_decide

/-- Theorem: Continuity check for Section 1(b) at $76,400 boundary. -/
theorem tax_section1_b_boundary_2_continuous :
  dollars 4440 + calculate_percent (dollars 76400 - dollars 29600) 28 100 = dollars 17544 := by native_decide

/-- Theorem: Continuity check for Section 1(b) at $127,500 boundary. -/
theorem tax_section1_b_boundary_3_continuous :
  dollars 17544 + calculate_percent (dollars 127500 - dollars 76400) 31 100 = dollars 33385 := by native_decide

/-- Theorem: Continuity check for Section 1(b) at $250,000 boundary. -/
theorem tax_section1_b_boundary_4_continuous :
  dollars 33385 + calculate_percent (dollars 250000 - dollars 127500) 36 100 = dollars 77485 := by native_decide

/-
Continuity checks for Section 1(c) Unmarried individuals.
Verifying that the tax calculated at the top of each bracket matches the base tax of the next bracket.
-/
/-- Theorem: Continuity check for Section 1(c) at $22,100 boundary. -/
theorem tax_section1_c_boundary_1_continuous :
  calculate_percent (dollars 22100) 15 100 = dollars 3315 := by native_decide

/-- Theorem: Continuity check for Section 1(c) at $53,500 boundary. -/
theorem tax_section1_c_boundary_2_continuous :
  dollars 3315 + calculate_percent (dollars 53500 - dollars 22100) 28 100 = dollars 12107 := by native_decide

/-- Theorem: Continuity check for Section 1(c) at $115,000 boundary. -/
theorem tax_section1_c_boundary_3_continuous :
  dollars 12107 + calculate_percent (dollars 115000 - dollars 53500) 31 100 = dollars 31172 := by native_decide

/-- Theorem: Continuity check for Section 1(c) at $250,000 boundary. -/
theorem tax_section1_c_boundary_4_continuous :
  dollars 31172 + calculate_percent (dollars 250000 - dollars 115000) 36 100 = dollars 79772 := by native_decide

/-
Continuity checks for Section 1(d) Married individuals filing separate returns.
Verifying that the tax calculated at the top of each bracket matches the base tax of the next bracket.
-/
/-- Theorem: Continuity check for Section 1(d) at $18,450 boundary. -/
theorem tax_section1_d_boundary_1_continuous :
  calculate_percent (dollars 18450) 15 100 = dollars_and_cents 2767 50 := by native_decide

/-- Theorem: Continuity check for Section 1(d) at $44,575 boundary. -/
theorem tax_section1_d_boundary_2_continuous :
  dollars_and_cents 2767 50 + calculate_percent (dollars 44575 - dollars 18450) 28 100 = dollars_and_cents 10082 50 := by native_decide

/-- Theorem: Continuity check for Section 1(d) at $70,000 boundary. -/
theorem tax_section1_d_boundary_3_continuous :
  dollars_and_cents 10082 50 + calculate_percent (dollars 70000 - dollars 44575) 31 100 = dollars_and_cents 17964 25 := by native_decide

/-- Theorem: Continuity check for Section 1(d) at $125,000 boundary. -/
theorem tax_section1_d_boundary_4_continuous :
  dollars_and_cents 17964 25 + calculate_percent (dollars 125000 - dollars 70000) 36 100 = dollars_and_cents 37764 25 := by native_decide

/-
Continuity checks for Section 1(e) Estates and Trusts.
Verifying that the tax calculated at the top of each bracket matches the base tax of the next bracket.
-/
/-- Theorem: Continuity check for Section 1(e) at $1,500 boundary. -/
theorem tax_section1_e_boundary_1_continuous :
  calculate_percent (dollars 1500) 15 100 = dollars 225 := by native_decide

/-- Theorem: Continuity check for Section 1(e) at $3,500 boundary. -/
theorem tax_section1_e_boundary_2_continuous :
  dollars 225 + calculate_percent (dollars 3500 - dollars 1500) 28 100 = dollars 785 := by native_decide

/-- Theorem: Continuity check for Section 1(e) at $5,500 boundary. -/
theorem tax_section1_e_boundary_3_continuous :
  dollars 785 + calculate_percent (dollars 5500 - dollars 3500) 31 100 = dollars 1405 := by native_decide

/-- Theorem: Continuity check for Section 1(e) at $7,500 boundary. -/
theorem tax_section1_e_boundary_4_continuous :
  dollars 1405 + calculate_percent (dollars 7500 - dollars 5500) 36 100 = dollars 2125 := by native_decide

/-
Placeholder for Section 1(f) regarding inflation adjustments, as requested by the "TODO" instruction for complex provisions.
-/
/--
IRC §1(f) Phaseout of marriage penalty in 15-percent bracket; adjustments in tax tables so that inflation will not result in tax increases.
TODO: Implement inflation adjustments. This requires definitions for CPI and other dynamic factors not fully specified in the provided text.
-/
def tax_section1_f_adjustments : Unit := ()

/-
Example evaluations to demonstrate the tax calculation functions.
1. Single filer with $50,000 income. Expected tax: $11,127 (1112700 cents).
2. Married joint filer with $100,000 income. Expected tax: $23,528.50 (2352850 cents).
-/
#eval calculate_tax FilingStatus.Single (dollars 50000)
#eval calculate_tax FilingStatus.MarriedFilingJointly (dollars 100000)

/-
Formal verification of the examples provided in the request.
Instead of #eval, we use theorems to assert the correctness of the calculations.
1. Single filer with $50,000 income results in $11,127 tax.
2. Married filing jointly with $100,000 income results in $23,528.50 tax.
-/
/-- Example: Calculate tax for a single filer with $50,000 income.
    $50,000 is in the bracket "Over $22,100 but not over $53,500".
    Tax = $3,315 + 28% of ($50,000 - $22,100).
    $50,000 - $22,100 = $27,900.
    28% of $27,900 = 0.28 * 27900 = $7,812.
    Total Tax = $3,315 + $7,812 = $11,127.
-/
theorem example_tax_single_50k : calculate_tax FilingStatus.Single (dollars 50000) = dollars 11127 := by native_decide

/-- Example: Calculate tax for a married joint filer with $100,000 income.
    $100,000 is in the bracket "Over $89,150 but not over $140,000".
    Tax = $20,165 + 31% of ($100,000 - $89,150).
    $100,000 - $89,150 = $10,850.
    31% of $10,850 = 0.31 * 10850 = $3,363.50.
    Total Tax = $20,165 + $3,363.50 = $23,528.50.
    Result should be in cents: 2352850.
-/
theorem example_tax_joint_100k : calculate_tax FilingStatus.MarriedFilingJointly (dollars 100000) = dollars_and_cents 23528 50 := by native_decide
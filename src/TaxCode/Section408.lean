/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1731ab85-dde2-429e-80df-9a3eed024a70
-/

/-
Formalization of IRC Section 408 (Individual Retirement Accounts).

This module defines the structures and validity requirements for:
- Individual Retirement Accounts (IRC §408(a))
- Individual Retirement Annuities (IRC §408(b))
- Employer and Employee Association Trusts (IRC §408(c))

It includes:
- Type definitions for `Currency`, `TaxYear`, `FilingStatus`, etc.
- Structures for `Contribution`, `Trust`, `IndividualRetirementAccount`, `AnnuityContract`, etc.
- Executable validity checks (`is_valid_ira`, `is_valid_annuity`, `is_valid_employer_trust`).
- Theorems verifying key legal properties (e.g., contribution limits, nonforfeitability).
- Examples using `#eval` to demonstrate valid and invalid scenarios.

The formalization handles the "cash only" and "contribution limit" rules, including the exception for rollover contributions. It also models the trustee requirements, life insurance prohibition, and nonforfeitability rules.

-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Basic definitions for Currency, TaxYear, and FilingStatus as requested.
-/
-- Common definitions
def Currency := Int

structure TaxYear where
  year : Nat
  h_valid : year ≥ 1913
  deriving DecidableEq

inductive FilingStatus
  | Single                         -- IRC §1(c)
  | MarriedFilingJointly          -- IRC §1(a)
  | MarriedFilingSeparately       -- IRC §1(d)
  | HeadOfHousehold               -- IRC §1(b)
  | QualifyingWidower             -- IRC §2(b)
  | Estate                         -- IRC §1(e)(1)
  | Trust                          -- IRC §1(e)(2)
  deriving Repr, DecidableEq, Inhabited

def mkTaxYear (y : Nat) : Option TaxYear :=
  if h : y ≥ 1913 then some ⟨y, h⟩ else none

/-
Adding typeclass instances to make Currency (defined as Int) usable with standard operations and literals.
-/
instance : Inhabited Currency := inferInstanceAs (Inhabited Int)
instance : Repr Currency := inferInstanceAs (Repr Int)
instance : Add Currency := inferInstanceAs (Add Int)
instance : Sub Currency := inferInstanceAs (Sub Int)
instance : Mul Currency := inferInstanceAs (Mul Int)
instance : Div Currency := inferInstanceAs (Div Int)
instance : LE Currency := inferInstanceAs (LE Int)
instance : LT Currency := inferInstanceAs (LT Int)
instance : DecidableEq Currency := inferInstanceAs (DecidableEq Int)
instance (n : Nat) : OfNat Currency n := ⟨(n : Int)⟩
instance : DecidableRel (· ≤ · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· ≤ · : Int → Int → Prop))
instance : DecidableRel (· < · : Currency → Currency → Prop) := inferInstanceAs (DecidableRel (· < · : Int → Int → Prop))

/-
Redefining types with abbrev to fix instance synthesis issues, and defining the IRA structures and validity check.
-/
instance : Repr TaxYear where
  reprPrec t _ := repr t.year

def section219_b_1_A_limit (year : TaxYear) : Currency :=
  if year.year = 2023 then 6500 else 7000

abbrev Person := String
abbrev Bank := String
abbrev InsuranceCompany := String

inductive ContributionType
  | Cash
  | Rollover
  | Other
  deriving DecidableEq, Repr

structure Contribution where
  amount : Currency
  type : ContributionType
  date : TaxYear
  contributor : Person
  deriving DecidableEq, Repr

structure Trust where
  trustee : Person
  beneficiaries : List Person
  assets : List Currency
  is_commingled : Bool
  invested_in_life_insurance : Bool
  deriving DecidableEq, Repr

structure IndividualRetirementAccount where
  owner : Person
  trust : Trust
  governing_instrument_written : Bool
  created_in_us : Bool
  exclusive_benefit : Bool
  interest_nonforfeitable : Bool
  deriving DecidableEq, Repr

def is_approved_trustee (p : Person) : Bool := true

def is_valid_ira (ira : IndividualRetirementAccount) (year : TaxYear) (contributions : List Contribution) : Bool :=
  let limit := section219_b_1_A_limit year
  let total_contribution := (contributions.filter (fun c => c.date = year && c.type != ContributionType.Rollover)).foldl (fun acc c => acc + c.amount) 0
  
  ira.governing_instrument_written &&
  ira.created_in_us &&
  ira.exclusive_benefit &&
  (contributions.all (fun c => c.type = ContributionType.Cash || c.type = ContributionType.Rollover)) &&
  (total_contribution <= limit) &&
  (is_approved_trustee ira.trust.trustee) &&
  (!ira.trust.invested_in_life_insurance) &&
  ira.interest_nonforfeitable &&
  (!ira.trust.is_commingled)

/-
Definitions for Individual Retirement Annuity and its validity requirements under IRC 408(b).
-/
-- IRC §408(b) Individual retirement annuity
structure AnnuityContract where
  issuer : InsuranceCompany
  owner : Person
  is_transferable : Bool
  premiums_fixed : Bool
  annual_premium : Currency
  refund_applied_to_future : Bool -- Simplified: true if refunds are applied correctly
  interest_nonforfeitable : Bool
  matures_later_than_70_half : Bool -- Simplified check for endowment contract maturity
  deriving DecidableEq, Repr

structure IndividualRetirementAnnuity where
  contract : AnnuityContract
  deriving DecidableEq, Repr

-- IRC §408(b) Requirements
def is_valid_annuity (annuity : IndividualRetirementAnnuity) (year : TaxYear) : Bool :=
  let limit := section219_b_1_A_limit year
  
  -- (1) Not transferable
  (!annuity.contract.is_transferable) &&
  -- (2)(A) Premiums not fixed
  (!annuity.contract.premiums_fixed) &&
  -- (2)(B) Annual premium limit
  (annuity.contract.annual_premium <= limit) &&
  -- (2)(C) Refunds applied to future premiums
  annuity.contract.refund_applied_to_future &&
  -- (3) Distribution rules (omitted)
  -- (4) Nonforfeitable
  annuity.contract.interest_nonforfeitable &&
  -- Endowment contract specific check (simplified)
  (!annuity.contract.matures_later_than_70_half)

/-
Definitions for Employer Trust (IRC 408(c)) and its validity requirements.
-/
-- IRC §408(c) Accounts established by employers and certain associations of employees
structure EmployerTrust where
  employer_or_association : Person
  trust : Trust
  participants : List Person
  separate_accounting : Bool -- IRC §408(c)(2)
  governing_instrument_written : Bool
  created_in_us : Bool
  exclusive_benefit : Bool
  interest_nonforfeitable : Bool -- Required by 408(a)(4) via 408(c)(1)
  deriving DecidableEq, Repr

-- IRC §408(c) Requirements
-- We assume `contributions` is a map or function giving contributions for each person
def is_valid_employer_trust (et : EmployerTrust) (year : TaxYear) (contributions : Person → List Contribution) : Bool :=
  let limit := section219_b_1_A_limit year
  
  -- (1) Meets requirements of (a)(1)-(6)
  -- (a)(1) Contributions: Cash only, limit check per participant
  (et.participants.all (fun p => 
    let p_contribs := contributions p
    let total := (p_contribs.filter (fun c => c.date = year && c.type != ContributionType.Rollover)).foldl (fun acc c => acc + c.amount) 0
    (p_contribs.all (fun c => c.type = ContributionType.Cash || c.type = ContributionType.Rollover)) &&
    (total <= limit)
  )) &&
  -- (a)(2) Trustee
  (is_approved_trustee et.trust.trustee) &&
  -- (a)(3) No life insurance
  (!et.trust.invested_in_life_insurance) &&
  -- (a)(4) Nonforfeitable
  et.interest_nonforfeitable &&
  -- (a)(5) Commingling: 408(c) allows common fund, so we check if it's a common fund or not commingled with *other* property.
  -- The `Trust` struct has `is_commingled`. We'll assume for `EmployerTrust` this refers to commingling with *outside* property.
  (!et.trust.is_commingled) &&
  -- (a)(6) Distribution rules (omitted)
  
  -- (2) Separate accounting
  et.separate_accounting &&
  
  et.governing_instrument_written &&
  et.created_in_us &&
  et.exclusive_benefit

/-
Theorems verifying key properties of valid IRAs, Annuities, and Employer Trusts.
-/
-- Theorems and Properties

-- Theorem: A valid IRA must have a written governing instrument
theorem valid_ira_implies_written_instrument (ira : IndividualRetirementAccount) (year : TaxYear) (contributions : List Contribution) :
  is_valid_ira ira year contributions → ira.governing_instrument_written := by
    unfold is_valid_ira; aesop;

-- Theorem: Contributions to a valid IRA must not exceed the limit (excluding rollovers)
theorem valid_ira_contribution_limit (ira : IndividualRetirementAccount) (year : TaxYear) (contributions : List Contribution) :
  is_valid_ira ira year contributions →
  let limit := section219_b_1_A_limit year
  let total_contribution := (contributions.filter (fun c => c.date = year && c.type != ContributionType.Rollover)).foldl (fun acc c => acc + c.amount) 0
  total_contribution <= limit := by
    unfold is_valid_ira; aesop;

-- Theorem: A valid annuity must be non-transferable
theorem valid_annuity_non_transferable (annuity : IndividualRetirementAnnuity) (year : TaxYear) :
  is_valid_annuity annuity year → !annuity.contract.is_transferable := by
    -- By definition of `is_valid_annuity`, the first condition is that the annuity is not transferable.
    simp [is_valid_annuity];
    aesop

-- Theorem: Employer trust participants must have nonforfeitable interest
theorem valid_employer_trust_nonforfeitable (et : EmployerTrust) (year : TaxYear) (contributions : Person → List Contribution) :
  is_valid_employer_trust et year contributions → et.interest_nonforfeitable := by
    unfold is_valid_employer_trust; aesop;

/-
Examples of valid and invalid IRAs using #eval to demonstrate the logic.
-/
-- Example: Valid IRA for Tax Year 2023
def year2023 : TaxYear := ⟨2023, by norm_num⟩

def john : Person := "John Doe"
def bank : Person := "Safe Bank"

def johnsTrust : Trust := {
  trustee := bank,
  beneficiaries := ["Jane Doe"],
  assets := [6500],
  is_commingled := false,
  invested_in_life_insurance := false
}

def johnsIRA : IndividualRetirementAccount := {
  owner := john,
  trust := johnsTrust,
  governing_instrument_written := true,
  created_in_us := true,
  exclusive_benefit := true,
  interest_nonforfeitable := true
}

def contribution1 : Contribution := {
  amount := 6500,
  type := ContributionType.Cash,
  date := year2023,
  contributor := john
}

-- Check validity
#eval is_valid_ira johnsIRA year2023 [contribution1]

-- Example: Invalid IRA (Excess contribution)
def contributionExcess : Contribution := {
  amount := 7000, -- Limit is 6500 for 2023
  type := ContributionType.Cash,
  date := year2023,
  contributor := john
}

#eval is_valid_ira johnsIRA year2023 [contributionExcess]

-- Example: Invalid IRA (Life Insurance)
def badTrust : Trust := {
  trustee := bank,
  beneficiaries := [],
  assets := [],
  is_commingled := false,
  invested_in_life_insurance := true -- Violation
}

def badIRA : IndividualRetirementAccount := {
  owner := john,
  trust := badTrust,
  governing_instrument_written := true,
  created_in_us := true,
  exclusive_benefit := true,
  interest_nonforfeitable := true
}

#eval is_valid_ira badIRA year2023 [contribution1]